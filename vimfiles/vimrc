if !has('vim9script') | throw 'vim9script feature not detected!' | endif
vim9script noclear
# helper function / const {{{1

# expand() should NOT be used to expand arbitrary file (like containing
# "[b-a]" in filename).
def ExpandHead(s: string): string
    if match(s, '\v^[%#<]') == 0
        return expand(s)
    elseif match(s, '\v^\~') == 0
        return expand('~') .. s[1 : ]
    elseif match(s, '\v^\$\ze[a-zA-Z_]') == 0
        const idx = match(s, '\v([^a-zA-Z_]|$)', 1)
        return expand(s[: idx - 1]) .. s[idx : ]
    endif
    return s
enddef

def g:ExpandHead(s: string): string
    return ExpandHead(s)
enddef

def TrSlash(s: string): string
    if has('win32')
        return substitute(s, '\', '/', 'g')
    else
        return s
    endif
enddef

const is_win32 = has('win32')
const is_linux = has('linux')
const is_mac = has('mac')
const is_wsl = executable('/mnt/c/Windows/notepad.exe')
const has_gui = has('gui_running') || is_mac || is_win32
    || (is_linux && (
        # desktop
        !empty($DISPLAY) || !empty($WAYLAND_DISPLAY)
        # android
        || executable('/data/data/com.termux/files/usr/bin/termux-open')
    ))

const is_conemu = is_win32 && !has('gui_running') && $CONEMUANSI ==? 'ON'

augroup vimrc
    au!
augroup END

# Plugins {{{1

set pp^=~/vimfiles

# disable default plugin {{{
g:loaded_2html_plugin = 1
g:loaded_getscriptPlugin = 1
g:loaded_gzip = 1
g:loaded_logiPat = 1
g:loaded_netrwPlugin = 1
g:loaded_tarPlugin = 1
g:loaded_vimballPlugin = 1
g:loaded_zipPlugin = 1  # }}}

# config definition for plugins not added via `:packadd[!]` {{{
g:tasks_config_paths =<< trim END
    ~/vimfiles/config/tasks.ini
    ~/vimfiles/config/tasks-local.ini
END
g:tasks_config_paths
    ->map((_, i) => expand(i))
    ->filter((_, i) => filereadable(i))

g:markdown_folding = 1
g:markdown_fenced_languages = [
    'awk', 'python', 'sh', 'vim',
    'c', 'go', 'javascript',
    'dosini', 'json', 'yaml',
    'zig',
]
# }}}

# use matchit, so vim9 filetype indent work as expected.
# https://github.com/vim/vim/issues/7628
packadd! matchit

packadd! securemodelines
packadd! tabular

# directory viewer
packadd! vim-dirvish
g:loaded_netrwPlugin = 1

# motion
packadd! vim-sneak
g:sneak#label = 1
# sneak unmap f / t when one of them is pressed after sneak key. {{{
# MRE:
#   :map t <Nop><CR>
#   sssff
#   :map t
# then mapping for t disappeared.
#
# since I only map t / T (f / F not mapped), only set t / T below.
# }}}
g:sneak#f_reset = 1
g:sneak#t_reset = 0
# I do not use vim-surround, so preserve s / S for vim-sneak.
vmap S <Plug>Sneak_S
omap s <Plug>Sneak_s
omap S <Plug>Sneak_S

# clipboard
const use_oscyank = !(has_gui || !empty($TMUX))
if use_oscyank
    packadd! vim-oscyank
endif

# git url
packadd! vim-gh-line
g:gh_line_map_default = 0
g:gh_line_blame_map_default = 0
if !has_gui
    # echo url only.
    g:gh_open_command = ''
endif
command! GitRepoUrl feedkeys("\<Plug>(gh-repo)")

# filetype / syntax
packadd! vim9-syntax
packadd! vim-tridactyl
packadd! vim-markdown-folding
g:markdown_fold_style = 'nested'
g:markdown_fold_override_foldtext = 0
# default yaml syntax is quite slow.
packadd! vim-yaml

# snippet (it uses <C-j> in normal / insert select mode)
packadd! miniSnip
# security: do not load snippets from cwd.
g:miniSnip_local = ''
# Spelling suggestions is usually not available, so let's override it.
g:miniSnip_complkey = '<C-x>s'

var using_coc = exists('g:did_coc_loaded')
# completion with coc {{{2
# coc.nvim setup: {{{
# - install from https://github.com/neoclide/coc.nvim;
# - `packadd coc.nvim` from $MYVIMRC;
# - recommend plugin:
#     CocInstall coc-json coc-pairs
# - useful setting:
#    "suggest.noselect": true
#    "diagnostic.enableSign": false
#    "suggest.minTriggerInputLength": 2
# }}}
if using_coc
    augroup vimrc
        # Highlight the symbol and its references when holding the cursor
        autocmd CursorHold * silent call g:CocActionAsync('highlight')

        set formatexpr=CocAction('formatSelected')
        &keywordprg = ":call g:CocActionAsync('doHover') | \""
        set tagfunc=CocTagFunc
    augroup END

    # Use `[g` and `]g` to navigate diagnostics
    # Use `:CocDiagnostics` to get all diagnostics of current buffer in location list
    nmap <silent> [g <Plug>(coc-diagnostic-prev)
    nmap <silent> ]g <Plug>(coc-diagnostic-next)

    # GoTo code navigation
    nmap <silent> gd <Plug>(coc-definition)
    nmap <silent> gy <Plug>(coc-type-definition)
    nmap <silent> gi <Plug>(coc-implementation)
    nmap <silent> gr <Plug>(coc-references)

    # C-n C-p
    inoremap <expr> <C-n> (coc#pum#visible() ? coc#pum#next(1) : coc#refresh())
    inoremap <expr> <C-p> (coc#pum#visible() ? coc#pum#prev(1) : coc#refresh())
endif

# completion without coc {{{2
# non-lsp {{{
# avoid i / t in 'cpt', since it may mess status bar when completion starts.
# - lsp or mucomplete?
set cpt=.,w,b,u
# don't select the first item.
set completeopt=menu,menuone,noselect
# suppress annoy messages.
set shortmess+=c

if !using_coc
    packadd! vim-mucomplete

    imap <expr> <Tab> (pumvisible() ? "\<plug>(MUcompleteCycFwd)" : "\<plug>(MUcompleteFwd)")
    imap <expr> <S-Tab> (pumvisible() ? "\<plug>(MUcompleteCycBwd)" : "\<plug>(MUcompleteBwd)")
    # make <CR> always add newline.
    inoremap <expr> <cr> pumvisible() ? "<c-y><cr>" : "<cr>"
endif

g:mucomplete#enable_auto_at_startup = 1
# disable its imap <Tab> (and some others)
g:mucomplete#no_mappings = 1
# disable keyn: included in c-n via option 'complete' ('cpt');
# about these chains description: help 'mucomplete-methods'
g:mucomplete#chains = {
    default: ['path', 'omni', 'snippet', 'user', 'c-n', 'dict'],
    vim:     ['path', 'cmd',  'snippet', 'user', 'c-n', 'dict'],
    # sql: disable omni, since it causes trouble. (dbext plugin is not installed)
    sql:     ['path',         'snippet', 'user', 'c-n', 'dict'],
}
g:mucomplete#user_mappings = {
    'snippet': "\<C-x>s",
}
g:mucomplete#can_complete = {
    default: {
        # it's completed even if word length is not enough; let's fix it.
        snippet: (s) => s->matchstr('\v\w+$')->len() >= 2,
    },
}

packadd! vim-dict
# always enable dict completion. (i_<Ctrl-x><Ctrl-k>)
execute 'set dict+=' .. globpath(&rtp, 'dict/text.dict', 0, 1)->get(0, '')->fnameescape()
# }}}

# lsp configuration helper function {{{
# convert {"x.y.z": xx} to {"x": {"y": {"z": xx} }}
# (vscode configuration style to canonical)
def ExpandJsonPtr(d: dict<any>): dict<any>
    var result = {}
    for [k_old, v] in items(d)
        var k: string = k_old
        var ptr: any = result
        while true
            const dot = match(k, '\V.')
            if dot > 0
                const key = k[ : dot - 1]
                if !has_key(ptr, key)
                    ptr[key] = {}
                endif
                ptr = ptr[key]
                k = k[dot + 1 : ]
            else
                ptr[k] = v
                break
            endif
        endwhile
    endfor
    return result
enddef

# for debug
#def g:ExpandJsonPtr(d: dict<any>): dict<any>
#    return ExpandJsonPtr(d)
#enddef
# }}}

# lsp server configuration {{{
const lspConfigDict = {
    ansible: {
        filetype: ['yaml.ansible'],
        path: 'ansible-language-server',
        args: ['--stdio'],
    },
    golang: {
        filetype: ['go', 'gomod'],
        path: 'gopls',
        args: ['serve'],
        syncInit: true,
    },
    python: {
        filetype: ['python'],
        path: (
            (!is_win32 && executable('pylsp')) ?
            expand('~/bin/pylsp-env-helper') :
            'pylsp'
        ),
        args: [],
        # https://github.com/python-lsp/python-lsp-server/blob/develop/CONFIGURATION.md
        workspaceConfig: ExpandJsonPtr({
            # disable (default enabled) style checking plugin:
            'pylsp.plugins.pyflakes.enabled': false,
            'pylsp.plugins.pycodestyle.enabled': false,
            # pylint reports [no-member], which is necessary;
            'pylsp.plugins.pylint.enabled': true,
            # only report error
            'pylsp.plugins.pylint.args': ['-E'],
        }),
    },
    scala: {
        filetype: ['scala'],
        path: 'metals',
        args: [],
    },
    typescript: {
        filetype: ['typescript', 'typescriptreact'],
        path: 'typescript-language-server',
        args: ['--stdio'],
    },
    ziglang: {
        filetype: ['zig'],
        path: 'zls',
        args: [],
    },
} # }}}
# allow extending / overriding from $MYVIMRC with var g:vimrc_lsp_config
->extend(exists('g:vimrc_lsp_config') ? g:vimrc_lsp_config : {})

# load lsp on demand {{{
if !using_coc
    for ft in lspConfigDict->values()->mapnew((_, i) => i.filetype)->flattennew()->sort()->uniq()
        execute $'au FileType {ft} LspSetup()'
    endfor

    var lsp_is_started: dict<bool> = {}
    def LspSetup()
        if !lsp_is_started->get(&ft, false)
            var config = {}
            for [k, v] in lspConfigDict->items()
                if v.filetype->index(&ft) >= 0
                    const exepath = exepath(v.path)
                    if empty(exepath)
                        return
                    endif
                    config = copy(v)
                    config.path = exepath
                    break
                endif
            endfor
            if empty(config)
                return
            endif
            lsp_is_started[&ft] = true
            if exists(':LspHover') != 2
                # lsp plugin is not loaded yet.
                # no ! here.
                packadd lsp
                g:LspOptionsSet({
                    # :help lsp-options
                    showDiagWithSign: false,
                })
            endif
            g:LspAddServer([config])
        endif

        # gq
        setlocal formatexpr=lsp#lsp#FormatExpr()
        # K
        setlocal keywordprg=:LspHover
        # ctrl-]
        setlocal tagfunc=lsp#lsp#TagFunc

        nnoremap <buffer> <silent> [g :LspDiag prev<CR>
        nnoremap <buffer> <silent> ]g :LspDiag next<CR>

        nnoremap <buffer> <silent> gd :LspGotoDefinition<CR>
        nnoremap <buffer> <silent> gy :LspGotoTypeDef<CR>
        nnoremap <buffer> <silent> gi :LspGotoImpl<CR>
        nnoremap <buffer> <silent> gr :LspShowReferences<CR>
    enddef
endif # }}}
# }}}2

# NOTE: plugin loading should be put **before** this. (see :help packadd)
# NOTE: filetype related autocmd should be put **after** this.
filetype plugin indent on
if !exists('g:syntax_on')
    syntax on
endif

# vimrc Detection {{{1

# Error if reading system-vimrc. {{{
# Some distribution's system-vimrc (like openSUSE) does sth,
# like set mapping, add autocmd.
# Some of these settings are good, but we want to keep these setting in vimrc
# (so it works for other distribution).
# To avoid duplicate setting, we just disable loading system-vimrc.
#
# Suggestion: put `exec /usr/bin/vim -Nu ~/vimfiles/vimrc "$@"` in ~/bin/vim,
# and add ~/bin in $PATH (before /usr/bin), so ~/bin/vim wins.
#
# In some environment (like git-for-windows), it is hard to put custom vim in
# $PATH.
# set vim variable g:vimrc_allow_system or env VIMRC_ALLOW_SYSTEM to 1 to skip check.
#
# Inspection of some distros' system vimrc:
#   git-for-windows:
#     - add autocmd to recover jump; safe to duplicate.
#   openSUSE:
#     - autocmd to recover jump (it's ok);
#     - some key mapping to cause <Ctrl-[> delay, this is not acceptable!
# }}}
const first_vimrc = execute('scr')->split("\n")->get(0)
    ->substitute('\v^.{-}:\s*', '', '')
    ->ExpandHead()
    ->TrSlash()

if has('vim_starting') && exists('$MYVIMRC') && first_vimrc != TrSlash($MYVIMRC)
    if !(
            !empty(get(g:, 'vimrc_allow_system'))
            || !empty($VIMRC_ALLOW_SYSTEM)
            )
        throw 'system-vimrc is read. skip loading vimrc!'
    endif
endif

if !exists('$MYVIMRC')
    # If we use `vim -u ...`, $MYVIMRC will not be set.
    # make ":e $MYVIMRC" work.
    $MYVIMRC = first_vimrc
endif

# Tiny build options {{{1

set nomodeline
set backspace=2
set expandtab
set shiftwidth=4
set number
set relativenumber
set hlsearch
set incsearch
set timeoutlen=5000
set ttimeoutlen=0
set cursorcolumn
set cursorline
set laststatus=1
set showcmd
set wildmenu
set completeopt-=preview
set shortmess-=S
set encoding=utf-8
set fileformats=unix,dos

# See: http://edyfox.codecarver.org/html/vim_fileencodings_detection.html
set fileencodings=ucs-bom,utf-8,cp936,gb18030,big5,euc-jp,euc-kr,latin1

# Option {{{1

# &rtp {{{2
# why not using = here? since we may want to add package before souring this
# file; `set rtp=XXX` here will cause problem.
set rtp^=~/vimfiles
set rtp+=~/vimfiles/after

# add ~/bin to $PATH {{{2
# Even when set ~/bin in $PATH via ~/.config/zshrc, it may not be added when
# invoking gvim from desktop session, then ":sh" / ":Sh" / ":term" may not
# work for command defined in ~/bin.
# So add it to $PATH in vim explicitly.
const env_path_sep = is_win32 ? ';' : ':'
const home_bin = expand('~/bin')
if index($PATH->split(env_path_sep), home_bin) < 0
    $PATH = home_bin .. env_path_sep .. $PATH
endif

# win32 environment prepare {{{2
if is_win32 && has('vim_starting')
    # Set shellslash, so file path completion returns slash based str, {{{
    # which works in sh environment and win32 shell (cmd is not supported?).
    # shellescape() also returns unix-shell-friendly string.
    # Windows XP does not like slash path; let's handle it in ":Start"
    # UserCommand. }}}
    set shellslash

    # set env for cygwin / msys2 shell (start via :!): $VIM, $MYVIMRC... {{{
    # It's better to override $VIM / $VIMRUNTIME via shell startup, so cygwin
    # vim has correct $VIM set (/usr/share/vim). }}}
    $VIM = TrSlash($VIM)
    $VIMRUNTIME = TrSlash($VIMRUNTIME)
    $MYVIMRC = TrSlash($MYVIMRC)

    # $HOME should be set to make git bash find ~.
    if !exists('$HOME')
        $HOME = TrSlash($USERPROFILE)
    else
        $HOME = TrSlash($HOME)
    endif

    # set &shell, and add dir of it to $PATH. {{{
    # console vim and gvim handle &shell differently:
    # When &shell contains whitespace and not quoted, console vim does not
    # work with ":!..." command: it calls _wsystem() currently, while in gvim
    # it calls CreateProcess(); Most importantly, quoting is handled
    # differently.
    # So only set shell when it does not contain special char.
    #
    # To make things simpler, use git path to find bash.
    # Then git should be installed where path does not contain speical char.
    #
    # NOTE: busybox sh cannot handle CJK correctly (chcp.exe / utf-8). Use
    # cygwin / msys2 derived shell (fullset) if possible.
    # }}}

    def Exepath(program: string): string  # {{{
        # exepath(xxx) returns xxx in current dir, which is not desired.
        # so let's wrap it; NOTE: `.exe` suffix should be set in param.
        for i in globpath($PATH->substitute('\', '/', 'g')->substitute(';', ',', 'g'), program, 0, 1)
            if i->match('\v[\/]') >= 0  # not in current dir
                return i
            endif
        endfor
        return ''  # not found
    enddef  # }}}

    def WindowsShellSetting() # {{{
        const git_path = Exepath('git.exe')->substitute('\', '/', 'g')

        if !(
                execute(':verbose set shell?')->split("\n")->get(-1)
                ->match('^\s*Last set from') < 0
                || &shell->match('^/') >= 0)
            # only set shell if it is not set or set to invalid value (like
            # /bin/sh when invoking from busybox shell).
            return
        endif

        if empty(git_path)
            # try busybox before giving up.
            if !Exepath('busybox.exe')->empty()
                &shell = 'busybox sh'
            endif
            return
        endif

        # git.exe, when invoking from git bash, has different paths. {{{
        # checking 4 times is enough.
        # $ find ./ -name git.exe  # from git root dir
        # ./bin/git.exe
        # ./cmd/git.exe
        # ./mingw64/bin/git.exe
        # ./mingw64/libexec/git-core/git.exe
        # }}}
        var depth = 4
        var git_root = git_path
        while depth > 0
            depth -= 1
            git_root = fnamemodify(git_root, ':h')
            if executable(git_root .. '/usr/bin/bash')
                break
            endif
        endwhile

        const bash_path = git_root .. '/usr/bin/bash'
        if !executable(bash_path)
            echoerr 'vimrc: bash not found in git dir; using MinGit?'
            return
        endif
        if bash_path->match(' ') >= 0
            # git-for-windows default install location contains whitespace.
            &shell = '"' .. bash_path .. '"'
        else
            &shell = bash_path
        endif
        if fnamemodify(exepath('find'), ':h') != fnamemodify(bash_path, ':h')
            # always add dir of shell to $PATH, so tools like find wins. {{{
            # (it will be messy when calling win32 find.exe in unix shell)
            # When running cygwin / msys2 shell via :!, bash_path here will be
            # translated to /usr/bin, which is feasible. }}}
            $PATH = fnamemodify(bash_path, ':h') .. ';' .. $PATH
        endif
    enddef # }}}

    WindowsShellSetting()

    # vim-sh config; busybox sh rc
    $ENV = expand('~/.config/zshrc')

    # set &shell related options. {{{
    # NOTE: to use '"' correctly, all '"' should be escaped with '\'.
    # like this:
    #   :!echo \"hello world\"
    # (so just use :Sh if possible: it is more user friendly, and does not
    # depend on &shell related setting) }}}
    if &shell->match('\v(bash|zsh|busybox(|.exe) sh)(|.exe)$') >= 0
        # these settings are from vim_faq, modified.
        # https://vimhelp.org/vim_faq.txt.html#faq-33.6
        &shellcmdflag = '-c'
        # shq seems to modify excmd very early; use sxq instead.
        &shellquote = ''
        &shellxquote = '"'
        # sxe take effect even when sxq is not "(", so set it to empty.
        # see vim-sh (search ":!start") for details.
        &shellxescape = ''
        # shellpipe / shellredir seems not required.
    endif

    # fix cjk inside vim inside conemu.
    if is_conemu
        &encoding = 'cp' .. libcallnr('kernel32.dll', 'GetACP', 0)
    endif
endif

# macvim {{{2
if has('gui_macvim') && has('vim_starting')
    set gfn=Monaco:h14
    for i in 'abcdefghijklmnopqrstuvwxyz1234567890'
        execute $"map \<D-{i}> \<M-{i}>"
        execute $"map! \<D-{i}> \<M-{i}>"
        execute $"tmap \<D-{i}> \<M-{i}>"
    endfor
    # adjust $PATH, like homebrew, python venv which are set via shell.
    $PATH = system("zsh -ic 'echo $PATH'")->trim()
endif

# Leader key {{{2
# set leader / localleader to unused key, so plugin is hardly to clash with
# our key.
# Refer: lacygoill's vimrc.
g:mapleader = "\<S-F10>"
g:maplocalleader = "\<S-F11>"

# use <Space> as *true* leader key.
noremap <Space> <Nop>
#nnoremap <Space><Space> :nmap <Char-60>Space<Char-62><CR>
nnoremap <Space><Space> <ScriptCmd>PickDisplayMap()<CR>
nnoremap <Space>;; :map <buffer><CR>

def PickDisplayMap() # {{{
    g:Pick(
        'display map',
        v:none,
        execute('map | map! | tmap')->split("\n"),
        (s) => {
                # do nothing
            }
    )
enddef # }}}

# shell {{{2
# 'shelltemp' or 'noshelltemp': {{{
# - In win32 gui, 'noshelltemp' makes ":!" and ":[range]w !" work like in unix:
# no external cmd window;
# (if guioptions contain '!', ":!" will not show cmd window anyway.)
#
# but encoding cannot be detected (e.g. in "r !")
#
# - In unix, 'noshelltemp' makes ":[range]w !" not create tempfile;
#
# but if guioptions contain '!', ":r !" would not write content to buffer.
#
# So do not change 'shelltemp' option (default on).
# }}}

if !is_win32
    const zsh_path = is_mac ? '/opt/homebrew/bin/zsh' : '/bin/zsh'
    if executable(zsh_path)
        &shell = zsh_path
    endif
endif

# cmdline completion {{{2
# defined here instead of legacy, since it is available only after version 8.x
set wildoptions=pum,fuzzy

# builtin terminal enhancement {{{2
def TerminalPaste()
    echo @"
    if @"[-1 : ] == "\n"
        echohl WarningMsg
        echo '<Newline> at end!'
        echohl NONE
    endif
    echo 'paste in terminal? (cursor may be at wrong place!) [y/N] '
    if tolower(nr2char(getchar())) == 'y'
        feedkeys("i\<C-w>" .. '""', 'n')
        redraws | echon 'pasted.'
    else
        redraws | echon 'cancelled.'
    endif
enddef

# define a function, so it can also be used in popup terminal.
def TerminalSetup()
    if &buftype != 'terminal'
        return
    endif
    setl nonu | setl nornu
    # plugin/jump.vim
    nmap <buffer> <CR> <Plug>(jump_to_file)
    vmap <buffer> <CR> <Plug>(jump_to_file)
    # clipboard
    nnoremap <buffer> p :<C-u>call <SID>TerminalPaste()<CR>
    nnoremap <buffer> P :<C-u>call <SID>TerminalPaste()<CR>
    # dirvish
    if exists(':Dirvish') == 2
        nnoremap <buffer> - <Cmd>execute 'Dirvish' fnameescape(getcwd())<CR>
    endif
enddef

augroup vimrc
    au TerminalWinOpen * TerminalSetup()
augroup END

# window title {{{2
set title

# statusline {{{2
set ruler
&rulerformat = '%20('
    .. '%M'
    .. ' <%B>'
    .. ' %l:%{charcol(".")}%V'
    .. '%='
    .. '%P'
    .. '%)'

# viminfo {{{2
# &viminfo should be set with ^= (the first match will be used) {{{
# according to source code.
# (in file src/viminfo.c, function find_viminfo_parameter())
#
# if option is already present (like '1000), reset (like :so $MYVIMRC) would
# do nothing.
# }}}
set viminfo^='1000

# set locale {{{2
# DO NOT set lang for unix system (mainly linux?);
# since it affects locale of subprocess (like calling gui program from vim).
if is_win32
    # for msys2 / git-for-windows, set $LANG to make CJK display correctly.
    $LANG = 'en_US.UTF-8'
    # when libintl.dll is not available, message translation is disabled.
    # so no need to set "$LANG = 'en'". (see :help win32-gettext)
endif

# foldmethod {{{2
# it's too easy to use vim style folder in various text file.
# just set fdm=marker as default.
if has('vim_starting')
    set fdm=marker
endif

# sessionoptions; better ":mksession" option. {{{2
# do not include options in ssop; {{{
# since it breaks mapping with <ScriptCmd>. (like vim-fuzzy)
# Maybe we can use other way to dump mapping.
# }}}
set ssop=blank,curdir,folds,help,tabpages,winsize,terminal

# various vim dir & file {{{2
# copy from https://github.com/mhinz/vim-galore#temporary-files (modified)
# backup files
set backup
&backupdir = expand('~/.vim/files/backup' .. '//')
set backupext=-vimbackup
set backupskip=
# swap files
&directory = expand('~/.vim/files/swap' .. '//')
# use default value
#set updatecount =100
# undo files
set undofile
&undodir = expand('~/.vim/files/undo/')
# viewdir (:mkview / :loadview)
&viewdir = expand('~/.vim/files/view/')
# viminfo files
&viminfofile = expand('~/.vim/files/viminfo')

# create directory if needed
for t_dir in [
        &backupdir, &directory, &undodir, &viewdir,
        expand('~/.vim/sessions/'),
        expand('~/.vim/scratch/'),
        ]
    if !isdirectory(t_dir)
        mkdir(t_dir, 'p')
    endif
endfor

# disable some feature
set nobackup
set noundofile

# alt key in terminal {{{2
if !has('gui_running') && !is_win32
    # see ":set-termcap"
    for i in 'abcdefghijklmnopqrstuvwxyz1234567890'
        exec $"set <M-{i}>=\<Esc>{i}"
    endfor
    set ttimeoutlen=100
endif

# <S-Space> in terminal {{{2
# additional setup: map <S-Space> to RHS of t_F9 keybinding
# in terminal emulator setting.
#
# t_F9 is <F19>. see ":h 't_F9'"
# (map t_F9 in local vimrc (AFTER souring this file!), since it is hard to
# decide the universe keybinding in different terminal emulators;
# if the terminal emulator supports binding <F19>, then no modification
# required in local vimrc)
#exec "set t_F9=\<Esc>0"
map <F19> <S-Space>
map! <F19> <S-Space>
tmap <F19> <S-Space>

# disable mouse support by default. make terminal happier. {{{2
if !has('gui_running')
    set mouse=
endif

# IME {{{2
if is_win32
    # when im is on in insert mode, esc to normal mode with im off.
    set iminsert=2
endif

# fix scroll behavior (H, L, zz, zt, zb ...) {{{2
# this may be set by /etc/vimrc (e.g. in fedora); let's recover it.
set scrolloff=0

# term & gui (but not colorscheme) {{{2
# TODO g:terminal_ansi_colors works even if (no gui && no tgc). is this a bug?
# NOTE: no `set bg`; seems that terminal theme (dark / light) can be detected.
if has('gui_running')
    # go-!: uniform shell interface, like :!, :sh.
    set guioptions=!
    set lines=30
    set columns=120
    if is_win32
        &guifont = 'JetBrains_Mono_NL:h12:cANSI:qDRAFT'
    elseif is_linux
        &guifont = 'JetBrains Mono NL 12'
    endif
elseif is_win32 # win32 console version
    # Try to set termguicolors; if success, &t_Co will be changed to 256,
    # then we can use better looking colorscheme.
    # At least works in windows 10 (1809+?).
    #
    # setting it causes panic in console vim from headless wine.
    if windowsversion()->str2float() >= 10
        set tgc
    elseif is_conemu # DO NOT set term=xterm for windows 10+
        # https://conemu.github.io/en/VimXterm.html
        set term=xterm
        &t_Co = '256' # string required!
        &t_AB = "\e[48;5;%dm"
        &t_AF = "\e[38;5;%dm"
    endif
elseif &term == 'linux' # linux console
    ::
else # unix-like system, in terminal emulator
    # cursor shape (does not work if &term is set after init ?)
    &t_SI = "\<Esc>[5 q"
    &t_SR = "\<Esc>[4 q"
    &t_EI = "\<Esc>[1 q"

    # strikethrough
    if &term !~ 'xterm'
        &t_Ts = "\<Esc>[9m"
        &t_Te = "\<Esc>[0m"
    endif

    # 256color or tgc
    if &term !~ 'xterm'
        # make tgc work; :help xterm-true-color
        &t_8f = "\<Esc>[38:2:%lu:%lu:%lum"
        &t_8b = "\<Esc>[48:2:%lu:%lu:%lum"
    endif
    silent! set tgc

    if &term == 'xterm-kitty'
        # in kitty faq.
        &t_ut = ''
    endif

    if is_wsl && &term =~ 'xterm'
        # fix vim start in replace mode; https://superuser.com/a/1525060
        &t_u7 = ''
    endif

    if is_mac && $TERM_PROGRAM == 'Apple_Terminal'
        set notgc
    endif
endif

if (is_conemu || is_mac) && &term =~ 'xterm'
    # italic; terminfo is buggy on conemu / macos?
    &t_ZH = "\<Esc>[3m"
    &t_ZR = "\<Esc>[0m"
endif

# Key mapping {{{1

# make <C-r> in select mode work as expected for snippet plugin {{{2
snoremap <C-r> ;<C-h><C-r>

# custom text object {{{2
# all
vnoremap aa :<C-u>normal! ggVG<CR>
onoremap aa :<C-u>normal! ggVG<CR>
# line
vnoremap al :<C-u>normal! 0v$h<CR>
onoremap al :<C-u>normal! 0v$h<CR>
# line, strip space
vnoremap il :<C-u>normal! ^vg_<CR>
onoremap il :<C-u>normal! ^vg_<CR>
# fold
vnoremap az V]zo[zo
onoremap az :<C-u>normal! V]zo[zo<CR>
# fold, without marker. (trailing marker is not un-select. press k if it
# exists.)
vnoremap iz V]zo[zjo
onoremap iz :<C-u>normal! V]zo[zjo<CR>

# mswin: disable v_CTRL-X (which is not compatible with unix) {{{2
# use vim_starting check to avoid unexpected behavior (map and then re-source).
if is_win32 && has('vim_starting') && !empty(maparg('<C-x>', 'v'))
    vunmap <C-x>
endif

# <M-hjkl> {{{2
tnoremap <M-h> <C-w>h
tnoremap <M-j> <C-w>j
tnoremap <M-k> <C-w>k
tnoremap <M-l> <C-w>l

nnoremap <M-h> <C-w>h
nnoremap <M-j> <C-w>j
nnoremap <M-k> <C-w>k
nnoremap <M-l> <C-w>l

inoremap <M-h> <C-o><C-w>h
inoremap <M-j> <C-o><C-w>j
inoremap <M-k> <C-o><C-w>k
inoremap <M-l> <C-o><C-w>l

# <C-tab>; <M-t> {{{2
tnoremap <C-Tab> <C-w>gt
tnoremap <S-C-Tab> <C-w>gT

nnoremap <C-Tab> gt
nnoremap <S-C-Tab> gT

inoremap <C-Tab> <C-o>gt
inoremap <S-C-Tab> <C-o>gT

tnoremap <M-t> <C-w>:tabe<CR>
nnoremap <M-t> :tabe<CR>
inoremap <M-t> <C-o>:tabe<CR>

# <M-1> - <M-9> {{{2
for i in range(1, 8)
    execute $"tnoremap \<M-{i}> \<C-w>{i}gt"
    execute $"nnoremap \<M-{i}> {i}gt"
    execute $"inoremap \<M-{i}> \<C-o>\<C-w>{i}gt"
endfor
execute "tnoremap \<M-9> \<C-w>:tablast<CR>"
execute "nnoremap \<M-9> :tablast<CR>"
execute "inoremap \<M-9> \<C-o>:tablast<CR>"
# preserve <M-0> for DE / wm.

# t_<C-w> {{{2
# <C-w> as in terminal.
tnoremap <C-w> <C-w>.

# i_<C-u> {{{2
# from defaults.vim
inoremap <C-U> <C-G>u<C-U>

# <Space>t... for tab operation {{{2
for i in range(1, 8)
    execute $'nnoremap <Space>t{i} {i}gt'
endfor
# t0 do nothing.
nnoremap <Space>t9 <Cmd>tablast<CR>
# note there is a final <Space>.
nnoremap <Space>tm :tabmove 
nnoremap <Space>tt <Cmd>call <SID>TabOpenOrClose()<CR>

def TabOpenOrClose()
    if empty(&buftype) && empty(bufname()) && &swapfile && !&modified
            # avoid closing last tab.
            && tabpagenr('$') != 1
        wincmd c
    else
        tabe
    endif
enddef

# Normal: n / N {{{2
# always search forward / backward.
# https://vi.stackexchange.com/questions/2365/how-can-i-get-n-to-go-forward-even-if-i-started-searching-with-or#
noremap <expr> n 'Nn'[v:searchforward]
noremap <expr> N 'nN'[v:searchforward]

# v_* / v_#; like `g*` / `g#`, dep: Selection() {{{2
# feedkeys() second param: why not using 't'? {{{
#   because if using 't', then "\n" in first param will trigger <C-j> event,
#   which is what we define for other functions (see via `nmap <C-j>`). }}}
vnoremap <silent> * :<C-u>call feedkeys('/\V' .. substitute(escape(Selection(), '\/'), "\n", '\\n', 'g') .. "\n", 'n')<CR>
vnoremap <silent> # :<C-u>call feedkeys('?\V' .. substitute(escape(Selection(), '\/'), "\n", '\\n', 'g') .. "\n", 'n')<CR>

# gF / v_gF {{{2
# (handle column nr; v_gF handle line / column nr)
# using plugin/jump.vim.
nmap gF <Plug>(jump_to_file)
vmap gF <Plug>(jump_to_file)

# terminal escape; {{{2
# used to use <C-Space>, but it may be occupied by DE / OS. {{{
# I don't use <C-t> key in terminal, so it's ok to map it. }}}
tnoremap <C-t> <C-\><C-n>

# <Space>g; prompt to run code (and remember last command) {{{2
nnoremap <expr> <Space>g SpaceGSetup()
def SpaceGSetup(): string
    if !exists('b:space_g')
        const cmd = {
            go: 'go run %',
            javascript: 'node %',
            python: 'python3 %',
            scheme: 'scheme-run %',
            sh: (getline(1)->match('\v^\#\!.*<bash>') >= 0 ? 'bash' : 'sh') .. ' %:p',
            zig: 'zig run %',
            zsh: 'zsh %:p',
        }->get(&ft, '')
        b:space_g = $'up | Sh! -bt {cmd}'
        if &ft == 'gitcommit'
            b:space_g = 'Sh -t=vs,c ' .. (
                $GIT_DIR =~ $'{$HOME}/dotfiles/.git' ? 'git g dc' : 'git dc')
        endif
    endif
    feedkeys($':SpaceG {b:space_g}', 'n')
    return ''
enddef

command! -nargs=+ -complete=shellcmd SpaceG SpaceG(<q-args>)
def SpaceG(arg: string)
    b:space_g = arg
    execute b:space_g
enddef

# <Space>l {{{2
nnoremap <silent> <Space>l :noh<CR>

# <Space>sl / <Space>ss; mksession. {{{2
nnoremap <Space>sl :so ~/.vim/sessions/
nnoremap <expr> <Space>ss
            \ $':wall \| mksession{empty(v:this_session) ? "" : "!"}'
            \ .. $' {v:this_session ?? "~/.vim/sessions/"}'

# <Space>s...; :Sh related. {{{2
nnoremap <Space>st :Sh -t
nnoremap <Space>sw :Sh -w
# add space after vmap, since we usually want to do sth on input.
vnoremap <Space>st :Sh -vt 
vnoremap <Space>sw :Sh -vw 

# <Space>y / <Space>p; Clipboard {{{2
if use_oscyank
    nnoremap <Space>y :OSCYankRegister "<CR>
    nnoremap <Space>p :echoerr 'use system paste shortcut instead!'<CR>
else
    # use pbcopy / pbpaste in $PATH as clipboard; wayland / x11 / tmux ...
    # detection is defined there. (~/bin/{pbcopy,pbpaste})
    nnoremap <Space>y <ScriptCmd>ClipboardCopy("")<CR>
    nnoremap <Space>p <ScriptCmd>ClipboardPaste("")<CR>
endif

def ClipboardCopy(cmd_: string)
    var cmd = cmd_
    if empty(cmd)
        if has('clipboard') && is_win32
            # NOTE: unix: X11 clipboard content will disapper when program exits.
            # but kde (plasma) has clipboard manager, which make it work
            # consistently.
            # 20221029_133619 wrap stmt with 'execute', since it complains
            # that + register is not available. I guess this is introduced in
            # recent commit.
            execute '@+ = @"'
            return
        elseif executable('pbcopy')
            cmd = 'pbcopy'
        else
            throw 'clipboard not found!'
        endif
        system(cmd, @")
    else
        system(cmd, @")
    endif
enddef

def ClipboardPaste(cmd_: string)
    var cmd = cmd_
    if empty(cmd)
        if has('clipboard') && is_win32
            execute '@" = @+'
            return
        elseif executable('pbpaste')
            cmd = 'pbpaste'
        else
            throw 'clipboard not found!'
        endif
        @" = system(cmd)
    else
        @" = system(cmd)
    endif
enddef

# <Space><CR>; execute current line (or select lines), comment removed {{{2
nnoremap <Space><CR> <Cmd>call <SID>ExecuteLines('n')<CR>
vnoremap <Space><CR> :<C-u>call <SID>ExecuteLines('v')<CR>

def ExecuteLines(mode: string)
    var lines: list<string>
    if mode == 'n'
        lines = [getline('.')]
    elseif mode == 'v'
        lines = getline("'<", "'>")
    endif
    var result_l = []
    for i in lines
        result_l = add(result_l, substitute(i, '\v^\s*(//|#|"|--|;)+', '', ''))
    endfor
    var result: string = join(result_l, "\n")
    echom result
    echo 'execute? y/N '
    if nr2char(getchar())->tolower() == 'y'
        redraws
        try
            execute result
        finally
        endtry
    else
        redraws | echon 'cancelled.'
    endif
enddef

# <Space>n; switch number / relativenumber {{{2
nnoremap <silent> <Space>n <Cmd>call <SID>Switch_nu_rnu()<CR>

def Switch_nu_rnu()
    # no [0, 1]
    const presents = [[1, 1], [1, 0], [0, 0], [1, 1]]
        ->mapnew((_, i) => [i[0] == 1, i[1] == 1])
    const idx = index(presents, [&l:nu, &l:rnu])
    [&l:nu, &l:rnu] = presents[idx + 1]
enddef

# <Space>m; switch mouse {{{2
nnoremap <silent> <Space>m <Cmd>call <SID>Switch_mouse()<CR>

def Switch_mouse()
    if &mouse == 'a'
        set mouse=
    else
        set mouse=a
    endif
enddef

# <Space>q; switch quickfix window (open / focus or close) {{{2
nnoremap <silent> <Space>q <Cmd>call <SID>SwitchQuickfixWindow()<CR>

def SwitchQuickfixWindow()
    if &ft == 'qf'
        cclose
    else
        execute 'bot' 'copen' &cwh
    endif
enddef

# <Space>v; shortcut for reader mode. (view code / text easily.) {{{2
# TODO map more key (one hand); provide help page (double ? to enter search mode).
nnoremap <Space>v <Cmd>call <SID>SwitchReaderMode()<CR>
var reader_mode = exists('reader_mode') ? reader_mode :
    {on: false, winid: -1, timeoutlen: 0}

def SwitchReaderMode()
    const mapping =<< trim END
        q <Cmd>call <SID>SwitchReaderMode()<CR>
        <Space> <C-f>
        <S-Space> <C-b>
        f <C-f>
        b <C-b>
        d <C-d>
        u <C-u>
        e <C-e>
        y <C-y>
        x <C-w>c
        1 1gt
        2 2gt
        3 3gt
        4 4gt
        5 5gt
        6 6gt
        7 7gt
        8 8gt
        9 <Cmd>tablast<CR>
    END
    if reader_mode.on
        mapping->mapnew((_, i) => {
            execute 'nunmap' i->split(' ')[0]
        })
        &timeoutlen = reader_mode.timeoutlen
        reader_mode.on = false
        popup_close(reader_mode.winid)
    else
        mapping->mapnew((_, i) => {
            execute 'nnoremap' i
        })
        reader_mode.winid = popup_create(
            ['reader mode'], {
                line: &lines,
                mapping: false,
                highlight: 'Special',
                tabpage: -1,  # show in all tabs.
            }
        )
        reader_mode.timeoutlen = &timeoutlen
        # set to 0 to make <Space> work (skip mapping immediately).
        &timeoutlen = 0
        reader_mode.on = true
    endif
enddef

# cd; search cword with bing dict (in web browser) {{{2
nnoremap cd <ScriptCmd>OpenDict()<CR>
def OpenDict()
    const word = expand('<cword>')
    if !empty(word)
        execute 'Sh -g' shellescape($'https://www.bing.com/dict/search?mkt=zh-CN&q={word}')
    endif
enddef

# Autocmd {{{1

augroup vimrc
    # misc (filetype related) {{{2
    # NOTE: "au BufNewFile,BufRead XXX setf YYY" should be put in
    # ftdetect/ (if filetype will not be detected by system filetype.vim)
    # or filetype.vim (to take higher priority over system filetype.vim);
    # otherwise "au FileType YYY .*" stmt won't work.
    #
    # complex filetype setting should be put in ftplugin/.
    au FileType yaml setl indentkeys-=0#
    au FileType zig setl fp=zig\ fmt\ --stdin
    # ":h ft-sh-syntax"
    g:is_posix = 1
    au FileType snip {
        const ft = expand('<afile>')->split('/')->get(-2)
        if ft != 'all' && ft->match('\v^[a-zA-Z0-9_.]+$') >= 0
            execute $'setlocal filetype=snip.{ft}'
        endif
    }
    # completion from vim's help page into vim
    au FileType help setl iskeyword+=^'
    au FileType vim setl iskeyword+=:

    # quickfix window {{{2
    au FileType qf nnoremap <buffer> <C-n> <Cmd>cnewer<CR>
    au FileType qf nnoremap <buffer> <C-p> <Cmd>colder<CR>
    au FileType qf nnoremap <buffer> <C-j> <CR><C-w>p
    au FileType qf nnoremap <buffer> <Space>;l <Cmd>chistory<CR>

    # binary file editing. (ft=binary) {{{2
    # ReadBin / WriteBin impl {{{
    # avoid using busybox xxd. To use busybox xxd: `sed -E 's/  .*//' | xxd -r`;
    # since contents after 0x blocks are also parsed by busybox xxd.
    var xxd_path = 'xxd'
    # possible paths are from my vim-bin repo. (unix: $VIM/bin/xxd; win32:
    # $VIM/xxd.exe)
    const xxd_possible =<< eval trim END
        {$VIM}/bin/xxd
        {$VIM}/xxd.exe
    END
    for i in xxd_possible
        if filereadable(i)
            xxd_path = i
            break
        endif
    endfor

    def ReadBin(name: string)
        # we do not set 'shelltemp' option (to no); see relevant comment in
        # ~/vimfiles/vimrc.
        silent normal gg"_dG
        silent execute printf('r !%s %s', shellescape(xxd_path), shellescape(name))
        normal gg"_dd
        setl nomodified
    enddef

    def WriteBin(name: string)
        silent execute printf('w !%s -r > %s', shellescape(xxd_path), shellescape(name))
        if !empty(v:shell_error)
            return
        endif
        setl nomodified
        redrawstatus | echon 'written.'
    enddef
    # }}}

    command BinaryEditThis {
        const filename = expand('%:p')
        if !filename->filereadable()
            throw 'file associated to this buffer is not readable!'
        endif
        setl ft=binary
    }
    au FileType binary {
        if &modified
            throw 'file is changed! unable to set filetype to binary.'
        endif
        # if we don't set BufReadCmd, then re-edit file will not load binary data,
        # while BufWriteCmd still run xxd on write;
        # this will cause serious problem.
        au BufReadCmd <buffer> ReadBin(expand('<afile>'))
        # use do... since BufReadCmd will not take effect when defined after :e.
        do BufReadCmd
        au BufWriteCmd <buffer> WriteBin(expand('<amatch>'))
    }

    # network (non-local) file editing {{{2
    au BufReadCmd ftp://*,http://*,https://* {
        setl buftype=nofile
        # required if editing the same file (url) twice.
        setl modifiable
        execute 'Sh -r curl -sL --' shellescape(expand('<amatch>'))
        normal gg"_dd
        setl nomodifiable
    }

    # gx related (NOTE: key `gx` overwritten) {{{2
    nnoremap <silent> gx <ScriptCmd>Gx('n')<CR>
    vnoremap <silent> gx :<C-u>call <SID>Gx('v')<CR>

    def Gx(mode: string)
        var text: string
        if mode == 'v'
            var t = @"
            silent normal gvy
            text = @"
            @" = t
            if &buftype == 'terminal'
                text = substitute(text, "\n", '', 'g')
            endif
        else
            text = expand(get(g:, 'netrw_gx', '<cfile>'))
        endif
        if text->match('\v^[~$]') >= 0
            # expand ~ and $ (env).
            text = g:ExpandHead(text)
        endif
        echom text
        if has_gui
            execute 'Sh -g' text->shellescape()
        endif
    enddef

    # Remember the positions in files with some git-specific exceptions {{{2
    au BufReadPost * {
        # copied from /usr/share/vim/vim82/suse.vimrc
        if line("'\"") > 0 && line("'\"") <= line("$")
                    \ && expand("%") !~ "COMMIT_EDITMSG"
                    \ && expand("%") !~ "ADD_EDIT.patch"
                    \ && expand("%") !~ "addp-hunk-edit.diff"
                    \ && expand("%") !~ "git-rebase-todo"
            exe "normal g`\""
        else
            # fedora will do like if branch, but without checking whitelist;
            # so go to file head manually.
            exe 'normal gg0'
        endif
    }

    # open {file}:{line}[:{col}] automatically (provided by linter, etc). {{{2
    au BufNewFile * ReopenAsFileLineCol()

    def ReopenAsFileLineCol()
        var filename: string = bufname('%')
        var line: number = 0
        var column: number = 0
        if filename->filereadable()
            return
        endif
        if filename->matchstr('\v^.*\ze:[0-9]+:?$')->filereadable()
            line = filename->matchstr('\v.*:\zs[0-9]+\ze:?$')->str2nr()
            filename = filename->matchstr('\v^.*\ze:[0-9]+:?$')
        elseif filename->matchstr('\v^.*\ze:[0-9]+:[0-9]+:?$')->filereadable()
            column = filename->matchstr('\v.*:\zs[0-9]+\ze:?$')->str2nr()
            line = filename->matchstr('\v.*:\zs[0-9]+\ze:[0-9]+:?$')->str2nr()
            filename = filename->matchstr('\v^.*\ze:[0-9]+:[0-9]+:?$')
        endif
        if filename->filereadable()
            execute 'edit' filename->fnameescape()
            # this is used to make ftdetect (and many other things) work
            do BufRead
            if line > 0
                execute 'normal' line .. 'G'
                if column > 0
                    execute 'normal 0' (column - 1) .. 'l'
                endif
            endif
        endif
    enddef

    # fix % in cmdwin when matchit plugin enabled. {{{2
    au BufEnter * {
        if win_gettype() == 'command' && maparg('%', 'x') =~ 'Matchit'
            xnoremap <buffer> % %
        endif
    }

    # `run-some-shellcmd | vim -`, without "No write since..." warning {{{2
    au StdinReadPre * setl bt=nofile noswapfile

    # prompt creating parent directory for files. {{{2
    au BufWritePre * {
        const dir = expand('%:p:h')
        if !isdirectory(dir)
            redrawstatus
            echo $'dir [{dir}] does not exist. create it? [y/N] '
            const input = getcharstr()
            echo "\n" | redrawstatus
            if input->tolower() == 'y'
                mkdir(dir, 'p')
            endif
        endif
    }

    # day/light theme switching {{{2
    def DayLightTheme()
        if executable('darkman') && system('darkman get') =~ 'light'
            set bg=light
        else
            set bg=dark
        endif
    enddef
    if has_gui && is_linux
        au SigUSR1 * DayLightTheme()
        if has('vim_starting')
            # console vim can detect day/light theme;
            # but when run inside tmux, it cannot. So run this anyway.
            DayLightTheme()
        endif
    endif

augroup END  # {{{2

# Colorscheme {{{1

# only set colorscheme if not set yet. {{{2
# using `trim(execute('color')) == 'default'` is not valid.
if !exists('g:colors_name')
    if has('gui_running') || &t_Co->str2nr() >= 256
        color base16-dynamic
    else
        if is_win32
            # cmd.exe window
            color pablo
            set nocursorcolumn
        else
            color default
        endif
    endif
endif

# colorscheme tweak {{{2
def ColorSchemeTweak()
    hi! link StatusLineTermNC StatusLineNC

    # terminal 16color
    if (has('gui_running') || &tgc)
        # https://github.com/lxhillwind/base16-dynamic.vim
        if &bg == 'dark'
            g:terminal_ansi_colors = ["#263238", "#F07178", "#C3E88D", "#FFCB6B", "#82AAFF", "#C792EA", "#89DDFF", "#EEFFFF", "#546E7A", "#F07178", "#C3E88D", "#FFCB6B", "#82AAFF", "#C792EA", "#89DDFF", "#FFFFFF"]
        else
            g:terminal_ansi_colors = ["#fafafa", "#ca1243", "#50a14f", "#c18401", "#4078f2", "#a626a4", "#0184bc", "#383a42", "#a0a1a7", "#ca1243", "#50a14f", "#c18401", "#4078f2", "#a626a4", "#0184bc", "#090a0b"]
        endif
    endif

    # fix cterm underline in CursorLineNr
    hi CursorLineNr cterm=NONE
enddef

augroup vimrc
    # colorscheme may not change at startup.
    au ColorScheme * ColorSchemeTweak()
augroup END
ColorSchemeTweak()

# Command {{{1

# :CopyMatches  {{{2
# https://vim.fandom.com/wiki/Copy_search_matches#Copy_matches
# original snippet does not work...
command! CopyMatches CopyMatches()
def CopyMatches()
    var hits = []
    :%s//\=add(hits, submatch(0))/gne
    @" = join(hits, "\n") .. "\n"
enddef

# :ChdirTerminal [path]; default path: selection / <cfile>; expand() is applied; use existing terminal if possible; bang: using Sh -w (default: Sh -t) {{{2
# depends on g:Selection().
command! -bang -nargs=* -range=0 ChdirTerminal ChdirTerminal(<bang>false, <range>, <q-args>)

def ChdirTerminal(bang: bool, range: number, path_a: string)
    var path = path_a ?? ( range > 0 ? g:Selection() : expand('<cfile>') )
    if match(path, '\v^[~$<%]') >= 0
        path = g:ExpandHead(path)
    endif
    path = fnamemodify(path, ':p')
    if filereadable(path)
        path = fnamemodify(path, ':h')
    endif
    if !isdirectory(path)
        throw 'is not directory or not readable: ' .. path
    endif

    const bufs: list<number> = tabpagebuflist()
    if !bang
        for i in term_list()->filter(
                (_, x) => x->term_getstatus() == 'running'
                )
            const idx: number = index(bufs, i)
            if idx >= 0
                echo $'chdir in window [{idx + 1}]? [y/N] '
                if nr2char(getchar())->tolower() == 'y'
                    execute ':' .. (idx + 1) 'wincmd w'
                    call feedkeys(printf('%scd %s', mode() == 'n' ? 'i' : '', shellescape(path)), 't')
                else
                    redrawstatus | echon 'cancelled.'
                endif
                return
            endif
        endfor
    endif
    const cmd = bang ? 'Sh -w' : 'Sh -t'
    execute 'Cd' path ':' .. cmd
enddef

# :DiffOrig {{{2
# see help :DiffOrig
command! DiffOrig vert new | set bt=nofile | legacy r ++edit # | legacy 0d_
    | diffthis | wincmd p | diffthis

# <range>:J sep... (`J` with custom seperator) {{{2
command! -nargs=1 -range J JoinLines(<q-args>, <range>, <line1>, <line2>)
def JoinLines(sep: string, range: number, line1: number, line2: number)
    const result = getline(line1, line2)->join(sep)
    deletebufline('%', line1, line2)
    append(max([line1 - 1, 0]), result)
    normal k
enddef

# :Jobrun / :Jobqfrun / :Jobstop / :Joblist / :Jobclear {{{2
command! -range=0 -nargs=+ -complete=shellcmd Jobrun
    | JobRun(<q-args>, {range: <range>, line1: <line1>, line2: <line2>, qf: false})
command! -range=0 -nargs=+ -complete=shellcmd Jobqfrun
    | JobRun(<q-args>, {range: <range>, line1: <line1>, line2: <line2>, qf: true})
command! -nargs=* -bang -complete=custom,JobStopComp Jobstop
    | JobStop(<q-args>, <bang>0 ? 'kill' : 'term')
command! Joblist JobList()
command! -count Jobclear JobClear(<count>)

var job_dict = exists('job_dict') ? job_dict : {}

def JobOutCb(ctx: dict<any>, _: channel, msg: string)
    const buf = ctx.bufnr
    setqflist([], 'a', {nr: buf, lines: [msg]})
enddef

def JobExitCb(ctx: dict<any>, job: job, ret: number)
    const buf = ctx.bufnr
    var data = []
    add(data, '')
    add(data, '===========================')
    add(data, 'command finished with code ' .. ret)
    if ctx.qf
        setqflist([], 'a', {nr: buf, lines: data})
    else
        appendbufline(buf, '$', data)
    endif
enddef

def JobRun(cmd_a: string, opt: dict<any>)
    if exists(':Sh') != 2
        throw 'depends on vim-sh plugin!'
    endif
    if exists(':ScratchNew') != 2
        throw 'depends on `:ScratchNew`!'
    endif
    var cmd: string = cmd_a
    var flag: string = '-n'
    if match(cmd, '^-') >= 0
        var tmp = matchlist(cmd, '\v^(-\S+)\s+(.*)$')
        cmd = tmp[2]
        flag = tmp[1] .. 'n'
    endif
    var cmd_short = cmd
    if opt.range != 0
        cmd = $':{opt.line1},{opt.line2}Sh {flag} {cmd}'
    else
        cmd = $'Sh {flag} {cmd}'
    endif
    var job_d = json_decode(execute(cmd))

    # in case running with ":Cd... [path]"
    extend(job_d.opt, {cwd: getcwd()})

    var bufnr: number
    if opt.qf
        var current_max = getqflist({nr: '$'}).nr
        bufnr = current_max + 1
        setqflist([], ' ',
            {
                title: '(:Joblist to check state) ' .. cmd_short, nr: bufnr,
            })
        extend(job_d.opt, {
            out_cb: function(JobOutCb, [{bufnr: bufnr}]),
            err_cb: function(JobOutCb, [{bufnr: bufnr}]),
        })
    else
        ScratchNew
        bufnr = bufnr()
        wincmd p
        extend(job_d.opt, {
            out_io: 'buffer', err_io: 'buffer',
            out_buf: bufnr, err_buf: bufnr,
        })
    endif
    extend(job_d.opt, {
        exit_cb: function(JobExitCb, [{bufnr: bufnr, qf: opt.qf}]),
    })

    extend(job_dict, {
        [bufnr]: {
            job: job_start(job_d.cmd, job_d.opt),
            cmd: cmd_short,
        }
    })
enddef

def JobStop(id_a: string, sig: string)
    var id = empty(id_a) ? bufnr() : str2nr(matchstr(id_a, '\v^\d+'))
    if has_key(job_dict, id)
        job_stop(job_dict[id].job, sig)
    else
        throw 'job not found: buffer id ' .. id
    endif
enddef

def JobStopComp(...arg: list<any>): string
    var result = []
    for [k, v] in items(job_dict)
        if v.job->job_status() == 'run'
            add(result, $'{k}: {v.cmd}')
        endif
    endfor
    return join(result, "\n")
enddef

def JobList()
    for [k, v] in items(job_dict)
        echo $"{k}:\t{v.job->string()}\t{v.cmd}"
    endfor
enddef

def JobClear(num: number)
    for item in num > 0 ? [num] : keys(job_dict)
        var job = get(job_dict, item)
        if !empty(job)
            if job.job->job_info().status != 'run'
                remove(job_dict, item)
            endif
        endif
    endfor
enddef

# :Lf; call lf in current buffer (as a replacement to vim-dirvish) {{{2
command! -nargs=* Lf Lf(<q-args>)

def Lf(arg: string)
    if !executable('lf')
        throw 'lf is not found in $PATH!'
    endif
    const result_file = tempname()
    const shcmd = 'lf -selection-path ' .. shellescape(result_file)
        .. (arg->empty() ? '' : ' ' .. shellescape(expand(arg)))
    var cmd_opt = execute($'Sh -n {shcmd}')->json_decode()
    const old_bufnr = bufnr()
    cmd_opt.opt->extend({
        curwin: true, term_finish: 'close', hidden: true,
        exit_cb: (_, _) => {
            if !filereadable(result_file)
                if bufexists(old_bufnr)
                        # only restore buffer when it does not show
                        && tabpagebuflist()->index(old_bufnr) < 0
                    execute $'buffer {old_bufnr}'
                endif
                return
            endif
            # TODO multiple line / file in result?
            const result = result_file->readfile()->get(0, "")
            if filereadable(result)
                execute 'edit' fnameescape(result)
            endif
        }
    })
    term_start(cmd_opt.cmd, cmd_opt.opt)
enddef

# :MatchLongLine {number} {{{2
# Refer: https://stackoverflow.com/a/1117367
command! -nargs=1 MatchLongLine exe ':/\%>' .. <args> .. 'v.\+'

# :OpenWithVSCode {{{2
command! OpenWithVSCode {
    const file = expand('%:p')
    const line = line('.')
    const column = charcol('.')
    const param = empty(file) ? 'code -n ./' : (
        printf('code -n ./ && code -r -g %s:%s:%s', shellescape(file), line, column)
    )
    execute 'Cdproject' 'Sh' param
}

# :Pick {shellcmd...} (depends on g:Pick()) {{{2
command! -nargs=+ -complete=shellcmd Pick PickAnyCli(<q-args>)

def PickAnyCli(cli: string)
    g:Pick(
        v:none,
        cli,
        v:none,
        (s) => {
            execute('e ' .. fnameescape(s))
        }
    )
enddef

# :PluginReadme {plugin}; open README file for specified plugin. {{{2
command! -nargs=1 -complete=custom,PluginReadmeComp PluginReadme
    | PluginReadme(<q-args>)

def PluginReadme(plugin: string)
    for i in PluginReadmeCache()
        if i->match(plugin) >= 0
            exec 'edit' i->fnameescape()
            return
        endif
    endfor
    echoerr 'plugin README not found: ' .. plugin
enddef

def PluginReadmeComp(..._: list<any>): string
    return PluginReadmeCache()
        ->mapnew((_, i) => i->substitute('\v.*/\ze[^/]+/[^/]+$', '', ''))
        ->join("\n")
enddef

var plugin_readme_cache: list<string> = []
var plugin_readme_set: bool = false
def PluginReadmeCache(): list<string>
    if !plugin_readme_set
        plugin_readme_cache = globpath(&rtp, 'README*', 0, 1)
        plugin_readme_set = true
    endif
    return plugin_readme_cache
enddef

# :QutebrowserEditCmd {{{2
if !empty($QUTE_FIFO)
    command! QutebrowserEditCmd QutebrowserEditCmd()

    def QutebrowserEditCmd()
        setl buftype=nofile noswapfile
        setline(1, $QUTE_COMMANDLINE_TEXT[1 :])
        setline(2, '')
        setline(3, 'hit `<Space>q` to save cmd (first line) and quit')
        # weired bug with `map ... \| q...` in vim9script.
        legacy nnoremap <buffer> <Space>q :call writefile(['set-cmd-text -s :' .. getline(1)], $QUTE_FIFO) \| q<CR>
    enddef
endif

# :Scratch [filetype] / :ScratchNew [filetype] (with new window) {{{2
command -nargs=? -complete=filetype Scratch Scratch(<q-args>)
command! -nargs=? -complete=filetype ScratchNew SnippetInNewWindow(<q-args>)

def Scratch(ft: string)
    enew | setl buftype=nofile noswapfile bufhidden=hide
    if !empty(ft)
        exe 'setl ft=' .. ft
    endif
enddef

def SnippetInNewWindow(ft: string)
    exe $'bel :{&cwh}new'
    setl buftype=nofile noswapfile
    setl bufhidden=hide
    if !empty(ft)
        exe 'setl ft=' .. ft
    endif
enddef

# Selection() {{{2
def g:Selection(): string
    const tmp = @"
    var result = ''
    var success = false
    try
        silent normal gvy
        success = true
    finally
        result = @"
        @" = tmp
        if !success
            throw 'g:Selection() failed!'
        endif
    endtry
    return result
enddef

# :SetCmdText / SetCmdText() {{{2
def g:SetCmdText(text: string)
    feedkeys(':' .. text, 't')
enddef

command! -nargs=+ SetCmdText g:SetCmdText(<q-args>)

# :ShebangInsert [content after "#!/usr/bin/env "] {{{2
command! -nargs=* -complete=shellcmd ShebangInsert ShebangInsert(<q-args>)

g:vimrc_shebang_lines = {
    'awk': 'awk-f',  # awk: wrapper executing "awk -f" is required.
    'javascript': 'node', 'lua': 'lua',
    'perl': 'perl', 'python': 'python', 'ruby': 'ruby',
    'scheme': 'scheme-run',  # scheme: see ~/bin/scheme-run
    'sh': '/bin/sh', 'zsh': 'zsh',
}

def ShebangInsert(args: string)
    const first_line = getline(1)
    if len(first_line) >= 2 && first_line[0 : 1] == '#!'
        throw 'shebang exists!'
    endif
    var shebang: string
    if has_key(g:vimrc_shebang_lines, args)
        shebang = g:vimrc_shebang_lines[args]
    elseif !empty(args)
        shebang = args
    elseif has_key(g:vimrc_shebang_lines, &ft)
        shebang = g:vimrc_shebang_lines[&ft]
    else
        throw 'shebang: which interpreter to run?'
    endif
    if match(shebang, '^/') >= 0
        shebang = '#!' .. shebang
    else
        shebang = '#!/usr/bin/env ' .. shebang
    endif
    # insert at first line and leave cursor here (for further modification)
    normal ggO<Esc>
    var ret = setline(1, shebang)
    if ret == 0  # success
        normal $
    else
        throw 'setting shebang error!'
    endif
enddef

# :VimRun {vim_command}... (run vim command) {{{2
command! -nargs=+ -complete=command VimRun ShowOutput(execute(<q-args>))

# :VimExpr {vim_expr}... (run vim expr) {{{2
command! -nargs=+ -complete=expression VimExpr ShowOutput(eval(<q-args>))

def ShowOutput(...data_: list<any>)
    # eval() return type may not be string, so use list<any> here.
    const data = type(data_[0]) == type('') ? data_[0] : string(data_[0])
    ScratchNew
    for line in split(data, "\n")
        append('$', line)
    endfor
    norm gg"_dd
enddef

# :EditFilenameInScratch (edit filename in scratch buffer) {{{2
command! EditFilenameInScratch EditFilenameInScratch()

def EditFilenameInScratch()
    wincmd s
    const title = expand('%:p')
    Scratch
    setline(1, title)
enddef

# :<range>Reverse (reverse selected lines) {{{2
command! -range Reverse keeppatterns :<line1>,<line2>g/^/m <line1>-1

# :Yank [...] (yank; default filename; otherwise expand(<q-args>)) {{{2
command! -nargs=* Yank @" = expand(empty(<q-args>) ? '%:t' : <q-args>)

# :ScratchWithName (like :Scratch, named; so it can be saved with `mksession`) {{{2
command! -nargs=? ScratchWithName ScratchWithName(<q-args>)
def ScratchWithName(name: string)
    const scratch_dirs = expand('~/.vim/scratch/')
    var filename = scratch_dirs .. name
    if empty(name)
        const files = globpath(scratch_dirs, '*', 0, 1)
        var i = 0
        while i < 10000
            filename = scratch_dirs .. string(i)
            if index(files, filename) < 0
                break
            endif
            i += 1
        endwhile
        if index(files, filename) >= 0
            throw 'too many files in scratch dir! "' .. scratch_dirs .. '"'
        endif
    endif
    exec 'e' fnameescape(filename)
enddef

# UserFunction {{{1

def g:NoteIdNew(): string # {{{2
    return strftime('%Y%m%d_%H%M%S')
enddef

def g:Pick(Title: string = '', Cmd: string = '', Lines: list<string> = [], Callback: func(any) = v:none)  # {{{2
    const fzf = (
        is_win32 && windowsversion()->str2float() <= 5.1
        ? 'fzf --color=16 --sort --cycle --reverse --inline-info'  # old fzf does not support --info.
        : 'fzf --color=16 --sort --cycle --reverse --info=inline'
    )
    var shcmd = ''
    const file_result = tempname()
    if empty(Cmd)  # Lines may be empty but provided; so checking Cmd is better.
        const file_input = tempname()
        Lines->writefile(file_input)
        shcmd = printf('%s < %s > %s', fzf, shellescape(file_input), shellescape(file_result))
    else
        shcmd = printf('{ %s 2>/dev/null; } | %s > %s', Cmd, fzf, shellescape(file_result))
    endif
    # use :Sh instead of :term, since latter does not work in win32:
    # e.g. `:term ++shell ls -l` will be trimmed as `ls`.
    var cmd_opt = execute($'Sh -n {shcmd}')->json_decode()
    cmd_opt.opt->extend({term_finish: 'close', hidden: true})
    const term_buf = term_start(cmd_opt.cmd, cmd_opt.opt)
    const height = max([&lines / 2, 10])
    const winid = popup_create(term_buf, {
        title: empty(Title) ? Cmd : Title,
        pos: 'botleft',  # use bot instead of top, since latter hides tab info.
        minwidth: &columns,
        minheight: height,
        maxheight: height,
        line: &lines,  # use 1 if use top as pos.
    })
    if is_win32
        # in win32, double <Esc> exits fzf; let's make it behave same as other OS.
        tnoremap <buffer> <Esc> <C-c>
    endif
    term_getjob(term_buf)
        ->job_setoptions({ exit_cb: (_, _) => {
            popup_close(winid)
            const res: string = file_result->readfile()->get(0, '')
            if !empty(res)
                redraws  # this is required to make Exception shown; {{{
                # like editing files already opened in another instance. }}}
                Callback(res)
            endif
        }})
enddef

# private pick function {{{2
def PickGotoProject() # {{{3
    g:Pick(
        'Project',
        ProjectListCmd(),
        v:none,
        (chosen) => {
            execute 'lcd' fnameescape(chosen)
            if exists(':Dirvish') == 2
                execute 'Dirvish' fnameescape(chosen)
            endif
        }
    )
enddef

# NOTE: this variable is directly put after `find` command,
# using shell syntax. QUOTE IT IF NECESSARY!
const project_dirs = '~/repos/ ~/vimfiles/'

# every item is put after -name (or -path, if / included)
const project_blacklist = ['venv', 'node_modules']

def ProjectListCmd(): string
    var blacklist = ''
    for i in project_blacklist
        if match(i, is_win32 ? '\v[/\\]' : '/') >= 0
            blacklist ..= printf('-path %s -prune -o ', shellescape(i))
        else
            blacklist ..= printf('-name %s -prune -o ', shellescape(i))
        endif
    endfor
    # https://github.com/lxhillwind/utils/tree/main/find-repo
    var find_repo_bin = exepath('find-repo' .. (is_win32 ? '.exe' : ''))
    if !find_repo_bin->empty()
        return printf('%s %s', shellescape(find_repo_bin), project_dirs)
    endif
    return (
        $'find {project_dirs} {blacklist} -name .git -prune -print0 2>/dev/null'
        .. ' | { if [ -x /usr/bin/cygpath ]; then xargs -r -0 cygpath -w; else xargs -r -0 -n 1; fi; }'
        .. " | sed -E 's#[\\/].git$##'"
    )
enddef

def PickGotoTabWin() # {{{3
    g:Pick(
        'TabWin',
        v:none,
        TabWinLines(),
        (chosen) => {
            const res = chosen->trim()->split(' ')
            const [tab, win] = [res[0], res[1]]
            execute $':{tab}tabn'
            execute $':{win}wincmd w'
        }
    )
enddef

def TabWinLines(): list<string>
    var buf_list = []  # preserve order
    var key: string
    for i in range(tabpagenr('$'))
        var j = 0
        for buf in tabpagebuflist(i + 1)
            key = printf('%d %d', i + 1, j + 1)
            buf_list->add(key .. ' ' .. bufname(buf))
            j = j + 1
        endfor
    endfor
    return buf_list
enddef

def PickJumpCurrentBuffer() # {{{3
    g:Pick(
        'CurrentBuffer',
        v:none,
        getline(1, '$')->mapnew((idx, i) => $'{idx + 1}: {i}'),
        (chosen) => {
            execute 'normal ' .. chosen->matchstr('\v^[0-9]+') .. 'G'
        }
    )
enddef

def PickRecentFiles() # {{{3
    const filesInCurrentTab = tabpagebuflist()
        ->mapnew((_, i) => i->getbufinfo())
        ->flattennew(1)->map((_, i) => i.name)
    const blacklistName = ["COMMIT_EDITMSG", "ADD_EDIT.patch", "addp-hunk-edit.diff", "git-rebase-todo"]
    g:Pick(
        'RecentFiles',
        v:none,
        v:oldfiles
        ->mapnew((_, i) => i)
        ->filter((_, i) => {
            const absName = i->ExpandHead()
            return absName->filereadable() && filesInCurrentTab->index(absName) < 0
                && blacklistName->index(fnamemodify(absName, ':t')) < 0
        }),
        (s) => {
            execute 'e' fnameescape(s)
        }
    )
enddef

def PickCwdFiles() # {{{3
    g:Pick(
        'CurrentDirFiles',
        executable('bfs') ? "bfs '!' -type d" : "find '!' -type d",
        v:none,
        (s) => {
            execute 'e' fnameescape(s)
        }
    )
enddef

def PickUserMapping() # {{{3
    if v:lang !~ '\v^(en|C$)'
        # change lang to C, so command 'verb map' outputs like
        # "Last set from", instead of using non-English message.
        defer execute($'language messages {v:lang}')
        language messages C
    endif
    const data = execute('verb map | verb map! | verb tmap')->split("\n")
    var keys: list<string>
    var values: list<string>
    {
        var prev: string
        for i in data
            if i->match('\s*Last set from') >= 0
                keys->add(prev)
                values->add(i)
            else
                prev = i
            endif
        endfor
    }
    g:Pick(
        'UserMapping',
        v:none,
        keys,
        (s) => {
            const idx = keys->index(s)
            if idx >= 0
                const line_info = values[idx]
                    ->matchlist('\vLast set from (.*) line (\d+)$')
                if !empty(line_info)
                    const [file, line] = line_info[1 : 2]
                    if bufname() != file
                        execute 'edit' fnameescape(file)
                    endif
                    execute $'normal {line}G'
                endif
            endif
        }
    )
enddef

def PickUserCommand() # {{{3
    if v:lang !~ '\v^(en|C$)'
        # ... see above (PickUserMapping)
        defer execute($'language messages {v:lang}')
        language messages C
    endif
    const data = execute('verb command')->split("\n")
    var keys: list<string>
    var values: list<string>
    {
        var prev: string
        for i in data
            if i->match('\s*Last set from') >= 0
                keys->add(prev)
                values->add(i)
            else
                prev = i
            endif
        endfor
    }
    g:Pick(
        'UserCommand',
        v:none,
        keys,
        (s) => {
            const idx = keys->index(s)
            if idx >= 0
                const line_info = values[idx]
                    ->matchlist('\vLast set from (.*) line (\d+)$')
                if !empty(line_info)
                    const [file, line] = line_info[1 : 2]
                    if bufname() != file
                        execute 'edit' fnameescape(file)
                    endif
                    execute $'normal {line}G'
                endif
            endif
        }
    )
enddef

# (keymap) popup to select from sources. {{{2
nnoremap <Space>a <ScriptCmd>SelectFromSources('a')<CR>
nnoremap <Space>f <ScriptCmd>SelectFromSources('f')<CR>

const pick_all = {
    a: [
        # [key, name, func]
        ['t', 'tabwin', PickGotoTabWin],
        ['b', 'current_buffer', PickJumpCurrentBuffer],
    ],
    f: [
        ['f', 'cwd_files', PickCwdFiles],
        ['r', 'recent_files', PickRecentFiles],
        ['p', 'project_dir', PickGotoProject],
        ['m', 'mapping', PickUserMapping],
        ['c', 'user_command', PickUserCommand],
    ],
}

def SelectFromSources(set: string)
    # TODO highlight
    const selection = pick_all[set]

    # Is is possible to use ordered dict, so we migrate selection /
    # selection_dict?
    var selection_dict = {}
    var lists = []
    for [k, v, f] in selection
        add(lists, $'[{k}] {v}')
        selection_dict[k] = f
    endfor
    var popup_opt = {
        pos: 'center',
        title: 'Select... (any other key to quit)',
        minwidth: min([40, &columns / 2]),
        border: [1, 1, 1, 1],
        mapping: false,
        filter: (winid: number, key: string): bool => {
            const Res = get(selection_dict, key)
            if !empty(Res)
                Res()
            endif
            # finally.
            popup_close(winid)
            return true
        }
    }
    popup_create(lists, popup_opt)
enddef

# TODO {{{1

# - toc / content: 'gO' in neovim; (help / markdown, etc.)
# - user completion; 'compl-function'. (tmux buffer, web browser, etc.)
# - search files (globpath(), executable() / exepath() without absolute path,
#   :packadd, :colorscheme) in win32 (wsl) is slow; try to avoid calling them
#   in vimrc.
#
# NOTE: DO NOT split vimrc. pro & con of maintaining a monolithic vimrc:
# - pro: easy to find out thing;
# - pro: plain layout, no magic;
# - con: not easy to find startuptime impact;
# - con: namespace (not suitable for short name var);

defc  # show error in this file early. {{{1 }}}1
# vim:fdm=marker:tw=78:sw=4
