" vim:fdm=marker:tw=78:sw=4

" vim9 header {{{1
if !has('vim9script')
    throw 'vim9script feature not detected!'
endif

vim9script noclear

# Error if reading system-vimrc.
#
# Some distribution's system-vimrc (like openSUSE) does sth,
# like set mapping, add autocmd.
# Some of these settings are good, but we want to keep these setting in vimrc
# (so it works for other distribution).
# To avoid duplicate setting, we just disable loading system-vimrc.
#
# Suggestion: put `exec /usr/bin/vim -Nu ~/vimfiles/vimrc "$@"` in ~/bin/vim,
# and add ~/bin in $PATH (before /usr/bin), so ~/bin/vim wins.
const first_vimrc = execute('scr')->split("\n")->get(0)
->substitute('\v^.{-}:\s*', '', '')
->expand()

if has('vim_starting') && exists('$MYVIMRC') && first_vimrc != $MYVIMRC
    echoerr 'system-vimrc is read. skip loading vimrc!'
    finish
endif

if empty('$MYVIMRC')
    # If we use `vim -u ...`, $MYVIMRC will not be set.
    # make ":e $MYVIMRC" work.
    $MYVIMRC = first_vimrc
endif

# config compatible with vim tiny version. {{{1
legacy function! s:config_with_legacy_comment() abort
" main {{{2
" if run vim with `-u xxx`, then &cp is set; disable it with `set nocp`.
" lines between `:if` and `:endif` will be ignored by vim tiny.
if &compatible
    set nocompatible
endif

set nomodeline

" backspace
set bs=2
" expandtab
set et
" shiftwidth
set sw=4
" (relative)number
set nu
set rnu
" hlsearch
set hls

" belloff
if exists('&bo')
    set bo=all
endif
" incsearch
set is
" timeoutlen
set tm=5000
" ttimeoutlen
set ttm=0
" cursorcolumn & cursorline
set cuc
set cul
" laststatus
set ls=2
" showcmd
set sc
" wildmenu
set wmnu
" completeopt
set cot-=preview
" shortmess; show search count message (default in neovim)
set shm-=S
" sessionoptions; better :mksession option.
set ssop=blank,curdir,folds,tabpages,winsize

" set locale in vimrc.vim, since vim tiny doesn't support :if.

" menu
set enc=utf-8
" fileencodings
" See: http://edyfox.codecarver.org/html/vim_fileencodings_detection.html
set fencs=ucs-bom,utf-8,cp936,gb18030,big5,euc-jp,euc-kr,latin1

" runtimepath
" for tiny version, set rtp to empty string to avoid loading any file.
"set rtp=

" finish. }}}2
endfunction

legacy call s:config_with_legacy_comment()

# common definition & setting {{{1
const is_unix = has('unix')
const is_win32 = has('win32')
const has_gui = has('gui_running') || has('mac')
|| (has('linux') && (!empty($DISPLAY) || !(empty($WAYLAND_DISPLAY))))

# &rtp / &pp
set rtp=~/vimfiles,$VIMRUNTIME,~/vimfiles/after
set pp=~/vimfiles,$VIMRUNTIME

# option {{{1
# win32 environment variable prepare {{{2
if is_win32
    # set $HOME (for unix shell), $PATH, $VIM ...
    def TrSlash(s: string): string
        return substitute(s, '\', '/', 'g')
    enddef

    # make it work in cygwin vim.
    $VIM = TrSlash($VIM)
    $VIMRUNTIME = TrSlash($VIMRUNTIME)
    $MYVIMRC = TrSlash($MYVIMRC)

    if !exists('$HOME')
        $HOME = TrSlash($USERPROFILE)
    else
        $HOME = TrSlash($HOME)
    endif

    var path = $PATH->split(';')->map((_, i) => TrSlash(i))
    for i in [
            expand('~/vimfiles/bin'),
            expand('~/bin'),
            ]
        if index(path, i) < 0 && isdirectory(i)
            $PATH = i .. ';' .. $PATH
        endif
    endfor
    # cygwin vim -> vim -> others.
    $PATH = '/usr/bin;/bin;' .. $VIMRUNTIME .. ';' .. $PATH

    # vim-sh config; busybox sh rc
    $ENV = expand('~/.config/zshrc')
endif

# unnamed... {{{2
# vim-vimserver should be called early.
packadd vim-vimserver

# map early
g:mapleader = ' '  # assign before use
g:maplocalleader = ' ;'
noremap <Space> <Nop>

augroup vimrc
    au!
augroup END

# builtin terminal enhancement {{{2
augroup vimrc
    def TerminalPaste()
        echo @"
        if @"[-1 : ] == "\n"
            echohl WarningMsg
            echo '<Newline> at end!'
            echohl NONE
        endif
        echo 'paste in terminal? (cursor may be at wrong place!) [y/N] '
        if tolower(nr2char(getchar())) == 'y'
            feedkeys("i\<C-w>" .. '""', 'n')
            redraws | echon 'pasted.'
        else
            redraws | echon 'cancelled.'
        endif
    enddef

    au TerminalOpen * {
        # NOTE: keymap defined here (terminal [p]aste).
        if &buftype == 'terminal'
            setl nonu | setl nornu
            # vim-jump
            nmap <buffer> <CR> <Plug>(jump_to_file)
            vmap <buffer> <CR> <Plug>(jump_to_file)
            nnoremap <buffer> p :<C-u>call <SID>TerminalPaste()<CR>
            nnoremap <buffer> P :<C-u>call <SID>TerminalPaste()<CR>
            # dirvish
            nnoremap <buffer> - <cmd>execute 'Dirvish' getcwd()<CR>
        endif
        }
augroup END

# statusline {{{2
&stl = '[%{winnr()},%{mode()}' .. '%{% empty(&buftype) ? "%M%R" : "" %}]'
.. '%{ empty(&ft) ? "" : " [".&ft."]" }'
.. ' %<'
.. '%{ &ft == "qf" && exists("w:quickfix_title") ? w:quickfix_title : "" }'
.. '%{% &ft == "qf" && exists("w:quickfix_title") ? "" : "%F" %}'
.. ' %=<%B>'
.. ' [%l:%{charcol(".")}'
.. '%{% &buftype == "terminal" ? "" : "/%L" %}' .. ']'

# set locale {{{2
if is_unix
    lang en_US.UTF-8
else
    $LANG = 'en'
endif

# various vim dir & file {{{2
# copy from https://github.com/mhinz/vim-galore#temporary-files (modified)
# backup files
set backup
&backupdir = expand('~/.vim/files/backup' .. '//')
set backupext=-vimbackup
set backupskip=
# swap files
&directory = expand('~/.vim/files/swap' .. '//')
# use default value
#set updatecount =100
# undo files
set undofile
&undodir = expand('~/.vim/files/undo/')
# viewdir (:mkview / :loadview)
&viewdir = expand('~/.vim/files/view/')
# viminfo files
&viminfofile = expand('~/.vim/files/viminfo')

# create directory if needed
for t_dir in [&backupdir, &directory, &undodir, &viewdir]
    if !isdirectory(t_dir)
        mkdir(t_dir, 'p')
    endif
endfor

# disable some feature
set nobackup
set noundofile

# term & gui (but not colorscheme) {{{2
# TODO g:terminal_ansi_colors works even if (no gui && no tgc). is this a bug?
if has('vim_starting')
    if has('gui_running')
        set guioptions=
        set lines=32
        set columns=128
    else
        if is_unix
            if $TERM->tolower() == 'linux'
                # linux tty
                set bg=dark
            else
                # 256color or tgc
                if exists('&tgc') && $TERM !~ 'xterm'
                    # make tgc work; :help xterm-true-color
                    &t_8f = "\<Esc>[38:2:%lu:%lu:%lum"
                    &t_8b = "\<Esc>[48:2:%lu:%lu:%lum"
                endif
                silent! set termguicolors
                if $BAT_THEME->tolower() =~ 'light'
                    set bg=light
                else
                    set bg=dark
                endif
            endif

            if $TERM->tolower() =~? 'xterm' && executable('/mnt/c/Windows/notepad.exe')
                # wsl; fix vim start in replace mode;
                # Refer: https://superuser.com/a/1525060
                set t_u7=
            endif
        else
            # win32 cmd
            set nocursorcolumn
        endif
    endif
endif

# alt key in terminal {{{2
if !has('gui_running') && is_unix
    # see ":set-termcap"
    for i in 'abcdefghijklmnopqrstuvwxyz1234567890'
        exec printf("set <M-%s>=\<Esc>%s", i, i)
    endfor
    set ttimeoutlen=100
endif

# plugin {{{1
# first, enable ":Pack" command.
packadd vim-pack

# disable default plugin {{{
g:loaded_2html_plugin = 1
g:loaded_getscriptPlugin = 1
g:loaded_gzip = 1
g:loaded_logiPat = 1
g:loaded_netrwPlugin = 1
g:loaded_tarPlugin = 1
g:loaded_vimballPlugin = 1
g:loaded_zipPlugin = 1

# some plugin installed by system package manager
g:loaded_fzf = 1
# }}}

# plugin config without install. {{{
g:tasks_config_paths =<< trim END
    ~/vimfiles/config/tasks.ini
    ~/vimfiles/config/tasks-local.ini
END

g:tasks_config_paths
->map((_, i) => expand(i))
->filter((_, i) => filereadable(i))

g:markdown_folding = 1

# keep sync with https://lxhillwind.gitee.io/ highlight.
# NOTE: zig is not available in hljs right now.
g:markdown_fenced_languages = [
    'awk', 'python', 'sh', 'vim',
    'c', 'go', 'javascript',
    'dosini', 'json', 'yaml',
    'zig',
    ]
# }}}

# mime {{{
Pack 'vim-filelist'
Pack 'vim-jump'
Pack 'vim-sh'
Pack 'pyvim'
g:pyvim_rc = expand('~/vimfiles/config/pyvim.py')
# }}}

# vim dist. {{{
# use matchit, so vim9 filetype indent work as expected.
# https://github.com/vim/vim/issues/7628
Pack 'matchit'
# }}}

# from network {{{
Pack 'https://github.com/justinmk/vim-dirvish', {'commit': 'b2b5709'}
g:loaded_netrwPlugin = 1

Pack 'https://github.com/justinmk/vim-sneak', {'commit': '94c2de47ab301d476a2baec9ffda07367046bec9'}
g:sneak#label = 1
# I do not use vim-surround, so preserve s / S for vim-sneak.
vmap S <Plug>Sneak_S
omap s <Plug>Sneak_s
omap S <Plug>Sneak_S

Pack 'https://github.com/tpope/vim-repeat', {'commit': '24afe922e6a05891756ecf331f39a1f6743d3d5a'}
Pack 'https://github.com/ciaranm/securemodelines', {'after': 1, 'commit': '9751f29699186a47743ff6c06e689f483058d77a'}

Pack 'https://github.com/masukomi/vim-markdown-folding', {'commit': '3f35acfb753cc9ea22182400b075c5b6e896ad71'}
g:markdown_fold_style = 'nested'
g:markdown_fold_override_foldtext = 0

Pack 'https://github.com/ziglang/zig.vim', {'commit': '0adf3a1407bdf60a6c1446fb6a9a05c9823e4290'}
Pack 'https://github.com/lacygoill/vim9-syntax', {'commit': '49895457b1fcae6407041a780932387bc681289a', 'skip': 1}
# }}}

# basic completion {{{
Pack 'https://github.com/skywind3000/vim-auto-popmenu', {'commit': 'ea64a79b23401f48e95b9bce65ba39c6c020a291'}
# enable this plugin for filetypes, '*' for all files.
#g:apc_enable_ft = {'text':1, 'markdown':1, 'php':1}
g:apc_enable_ft = {'*': 1}

# source for dictionary, current or other loaded buffers, see ':help cpt'
set cpt=.,k,w,b

# don't select the first item.
set completeopt=menu,menuone,noselect

# suppress annoy messages.
set shortmess+=c

Pack 'https://github.com/skywind3000/vim-dict', {'commit': 'b73128b'}
# File type override
#g:vim_dict_config = {'html':'html,javascript,css', 'markdown':'text'}
g:vim_dict_config = {'markdown': 'text'}

# Disable certain types
#g:vim_dict_config = {'text': ''}
# }}}

# coc; to install it, set var before source this file. {{{
if exists('g:plugin_set_coc') && !empty(g:plugin_set_coc)
    g:apc_enable_ft = {}

    Pack 'neoclide/coc.nvim', {'branch': 'release'}

    # vim completion
    Pack 'Shougo/neco-vim'
    Pack 'neoclide/coc-neco'

    # run the following vim command to install coc plugins:
    #   CocInstall coc-go
    #   CocInstall coc-html
    #   CocInstall coc-pyright

    augroup vimrc
        au FileType go,html,python,vim InitCocLang()
    augroup END

    # coc keymap
    def InitCocLang()
        # GoTo code navigation.
        nmap <silent> <buffer> <LocalLeader>d <Plug>(coc-definition)
        nmap <silent> <buffer> <LocalLeader>y <Plug>(coc-type-definition)
        nmap <silent> <buffer> <LocalLeader>i <Plug>(coc-implementation)
        nmap <silent> <buffer> <LocalLeader>r <Plug>(coc-references)

        # completion
        inoremap <silent> <buffer> <expr> <C-Space> coc#refresh()

        # diagnostic
        nmap <buffer> ]e <cmd>call CocAction('diagnosticNext')<CR>
        nmap <buffer> [e <cmd>call CocAction('diagnosticPrevious')<CR>

        # Use K to show documentation in preview window.
        nnoremap <silent> <buffer> K :call <SID>CocShowDocumentation()<CR>

        nnoremap <silent> <buffer> <C-]> <cmd>call <SID>CocDefinitionWithTagList()<CR>
    enddef

    def CocShowDocumentation()
        if (index(['vim','help'], &filetype) >= 0)
            execute 'h ' .. expand('<cword>')
        elseif (coc#rpc#ready())
            CocActionAsync('doHover')
        else
            execute '!' .. &keywordprg .. " " .. expand('<cword>')
        endif
    enddef

    # https://github.com/neoclide/coc.nvim/issues/576#issuecomment-632446784
    def CocDefinitionWithTagList()
        # Cribbed from :h tagstack-examples
        var tag = expand('<cword>')
        var pos = [bufnr()] + getcurpos()[1 :]
        var item = {'bufnr': pos[0], 'from': pos, 'tagname': tag}
        if CocAction('jumpDefinition')
            " Jump was successful, write previous location to tag stack.
            var winid = win_getid()
            var stack = gettagstack(winid)
            var stack['items'] = [item]
            settagstack(winid, stack, 't')
        endif
    enddef
endif
# }}}

# keymap {{{1
# terminal <C-Space>
map <Nul> <C-Space>
map! <Nul> <C-Space>
tmap <Nul> <C-Space>

tnoremap <M-h> <C-w>h
tnoremap <M-j> <C-w>j
tnoremap <M-k> <C-w>k
tnoremap <M-l> <C-w>l

nnoremap <M-h> <C-w>h
nnoremap <M-j> <C-w>j
nnoremap <M-k> <C-w>k
nnoremap <M-l> <C-w>l

inoremap <M-h> <C-o><C-w>h
inoremap <M-j> <C-o><C-w>j
inoremap <M-k> <C-o><C-w>k
inoremap <M-l> <C-o><C-w>l

tnoremap <C-Tab> <C-w>gt
tnoremap <S-C-Tab> <C-w>gT

nnoremap <C-Tab> gt
nnoremap <S-C-Tab> gT

inoremap <C-Tab> <C-o>gt
inoremap <S-C-Tab> <C-o>gT

tnoremap <M-t> <C-w>:tabe<CR>
nnoremap <M-t> :tabe<CR>
inoremap <M-t> <C-o>:tabe<CR>

for i in range(1, 8)
    execute printf("tnoremap \<M-%d> \<C-w>%dgt", i, i)
    execute printf("nnoremap \<M-%d> %dgt", i, i)
    execute printf("inoremap \<M-%d> \<C-o>\<C-w>%dgt", i, i)
endfor
execute "tnoremap \<M-9> \<C-w>:tablast<CR>"
execute "nnoremap \<M-9> :tablast<CR>"
execute "inoremap \<M-9> \<C-o>:tablast<CR>"
# preserve <M-0> for DE / wm.

# completion
inoremap <C-Space> <C-x><C-o>

# clear hlsearch
nnoremap <silent> <Leader>l :noh<CR>

# custom text object
vnoremap aa :<C-u>normal! ggVG<CR>
onoremap aa :<C-u>normal! ggVG<CR>
vnoremap al :<C-u>normal! 0v$h<CR>
onoremap al :<C-u>normal! 0v$h<CR>
vnoremap il :<C-u>normal! ^vg_<CR>
onoremap il :<C-u>normal! ^vg_<CR>

# filelist buffer; vim-filelist
nmap <Leader>f <Plug>(filelist_show)

# simple tasks: tasks.vim
nmap <Leader>r <Plug>(tasks-select)
vmap <Leader>r <Plug>(tasks-select)

# terminal escape
tnoremap <C-Space> <C-\><C-n>
tnoremap <C-w> <C-w>.

# filetype {{{1
filetype plugin indent on
if !exists('g:syntax_on')
    syntax on
endif

augroup vimrc
    au BufReadPost * {
        # "Remember the positions in files with some git-specific exceptions"
        # copied from /usr/share/vim/vim82/suse.vimrc
        if line("'\"") > 0 && line("'\"") <= line("$")
                    \ && expand("%") !~ "COMMIT_EDITMSG"
                    \ && expand("%") !~ "ADD_EDIT.patch"
                    \ && expand("%") !~ "addp-hunk-edit.diff"
                    \ && expand("%") !~ "git-rebase-todo"
            exe "normal g`\""
        endif
        }

    au BufNewFile,BufRead *.gv setl ft=dot
    au FileType yaml setl indentkeys-=0#
    au FileType zig setl fp=zig\ fmt\ --stdin
    au FileType markdown {
        setl tw=78

        hi link CheckboxUnchecked Type
        hi link CheckboxChecked Comment
        syn match CheckboxUnchecked '\v^\s*- \[ \] '
        syn match CheckboxChecked '\v^\s*- \[X\] '
        }

    # quickfix window
    au FileType qf &l:stl = &g:stl
    au FileType qf nnoremap <buffer> <C-n> <cmd>cnewer<CR>
    au FileType qf nnoremap <buffer> <C-p> <cmd>colder<CR>
    au FileType qf nnoremap <buffer> <C-j> <CR><C-w>p
    au FileType qf nnoremap <buffer> <LocalLeader>l <cmd>chistory<CR>

    # ":h ft-sh-syntax"
    g:is_posix = 1

    # viml completion
    au FileType vim inoremap <buffer> <C-Space> <C-x><C-v>

    # markdown checkbox {{{
    def MarkdownToggleTaskStatus()
        const lineno = line('.')
        var line = getline(lineno)
        if line =~ '\v^\s*- \[X\] '
            line = substitute(line, '\v(^\s*- )@<=\[X\] ', '', '')
        elseif line =~ '\v^\s*- \[ \] '
            line = substitute(line, '\v(^\s*- \[)@<= ', 'X', '')
        elseif line =~ '\v^\s*- '
            line = substitute(line, '\v(^\s*-)@<= ', ' [ ] ', '')
        endif
        setline(lineno, line)
    enddef
    # }}}
    au FileType markdown nnoremap <buffer>
                \ <LocalLeader>c :call <SID>MarkdownToggleTaskStatus()<CR>

    # simple filelist (vim-filelist)
    au FileType filelist {
        nmap <buffer> <LocalLeader><CR> <Plug>(filelist_cd)
        nmap <buffer> <CR> <Plug>(filelist_edit)
        }

    # gx related (NOTE: key `gx` overwritten) {{{
    nnoremap <silent> gx :call <SID>Gx('n')<CR>
    vnoremap <silent> gx :<C-u>call <SID>Gx('v')<CR>

    # TODO fix quote / escape
    def GxOpenCmd(s: string): list<string>
        if executable('xdg-open')
            return ['xdg-open', s]
        elseif executable('open')
            return ['open', s]
        elseif is_win32
            # TODO fix open for win32
            return ['cmd', '/c', isdirectory(s) ? 'explorer' : 'start', s]
        else
            echoerr 'do not know how to open' | return []
        endif
    enddef

    # TODO show error?
    def GxOpen(...arg: list<string>)
        const text = join(getline(1, '$'), "\n")
        if empty(text)
            return
        endif
        const open_cmd = empty(arg) ? GxOpenCmd(text) : [arg[0], text]
        if empty(open_cmd)
            return
        endif
        job_start(open_cmd, {stoponexit: ''})
    enddef

    def GxOpenGx(...arg: list<string>)
        if len(arg) == 1
            GxOpen(arg[0])
        else
            GxOpen()
        endif
        const winnr = winnr()
        wincmd p
        execute ':' .. winnr .. 'wincmd c'
    enddef

    def GxVim(...arg: list<string>)
        # a:1 -> cmd; a:2 -> text modifier; a:3 -> post string.
        var text = join(getline(1, '$'), "\n")
        if empty(text)
            return
        endif
        var cmd: string
        if len(arg) == 0
            cmd = text
        else
            if len(arg) >= 2 && !empty(arg[1])
                var Fun = arg[1]
                text = function(Fun)(text)
            endif
            cmd = arg[1] .. ' ' .. text
            if len(arg) >= 3 && !empty(arg[2])
                cmd ..= arg[2]
            endif
        endif
        exe cmd
    enddef

    def Gx(mode: string)
        var text: string
        if mode == 'v'
            var t = @"
            silent normal gvy
            text = @"
            @" = t
        else
            text = expand(get(g:, 'netrw_gx', '<cfile>'))
        endif
        exe printf('bel :%dnew', &cwh)
        # a special filetype
        setl ft=gx
        for line in split(text, "\n")
            append('$', line)
        endfor
        norm gg"_dd
    enddef

    def GxInit()
        setl buftype=nofile noswapfile
        setl bufhidden=hide
        if executable('qutebrowser')
            nnoremap <buffer> <LocalLeader>s :call <SID>GxOpen('qutebrowser')<CR>
        endif
        nnoremap <buffer> gx :call <SID>GxOpenGx()<CR>
        if executable('qutebrowser') && has_gui
            nnoremap <buffer> gs :call <SID>GxOpenGx('qutebrowser')<CR>
        endif
        nnoremap <buffer> <LocalLeader>f :call <SID>GxOpen()<CR>
        nnoremap <buffer> <LocalLeader>v :call <SID>GxVim("wincmd p \\|")<CR>
    enddef
    au FileType gx GxInit()
augroup END

# finally {{{2
# e.g. <Space><Space>
nnoremap <Leader><Leader> :nmap <Char-60>Leader<Char-62><CR>
# e.g. <Space>;; / \\
execute 'nnoremap <LocalLeader>' ..
(len(g:maplocalleader) > 1 ? matchstr(g:maplocalleader, '.$') : '<LocalLeader>') ..
' :nmap <Char-60>LocalLeader<Char-62><CR>'

# colorscheme {{{1
# only set colorscheme if not set yet. {{{2
# using `trim(execute('color')) == 'default'` is not valid.
if !exists('g:colors_name')
    if has('gui_running') || &t_Co->str2nr() >= 256
        color base16-dynamic
    else
        if is_win32
            # win32 cmd
            color pablo
        else
            # no 256color
            color default
        endif
    endif
endif

# terminal statusline tweak {{{2
augroup vimrc
    # colorscheme may not change at startup.
    au ColorScheme * hi! link StatusLineTermNC StatusLineNC
augroup END
hi! link StatusLineTermNC StatusLineNC

# terminal 16color {{{2
def TerminalAnsiColor()
    if !(has('gui_running') || &tgc)
        return
    endif
    # https://github.com/lxhillwind/base16-dynamic.vim
    if &bg == 'dark'
        g:terminal_ansi_colors = ["#263238", "#F07178", "#C3E88D", "#FFCB6B", "#82AAFF", "#C792EA", "#89DDFF", "#EEFFFF", "#546E7A", "#F07178", "#C3E88D", "#FFCB6B", "#82AAFF", "#C792EA", "#89DDFF", "#FFFFFF"]
    else
        g:terminal_ansi_colors = ["#fafafa", "#ca1243", "#50a14f", "#c18401", "#4078f2", "#a626a4", "#0184bc", "#383a42", "#a0a1a7", "#ca1243", "#50a14f", "#c18401", "#4078f2", "#a626a4", "#0184bc", "#090a0b"]
    endif
enddef

augroup vimrc
    au ColorScheme * TerminalAnsiColor()
augroup END
TerminalAnsiColor()

# gui {{{2
if has('gui_running')
    set gfn=Hack\ 14
    set bg=light
endif
# command {{{1
# clipboard {{{2
# use pbcopy / pbpaste in $PATH as clipboard; wayland / x11 / tmux ...
# detection is defined there. (~/bin/{pbcopy,pbpaste})
nnoremap <Leader>y :call <SID>ClipboardCopy("")<CR>
nnoremap <Leader>p :call <SID>ClipboardPaste("")<CR>

def ClipboardCopy(cmd_: string)
    var cmd = cmd_
    if empty(cmd)
        if executable('pbcopy')
            cmd = 'pbcopy'
        elseif has('clipboard')
            # NOTE: unix: X11 clipboard content will disapper when program exits.
            @+ = @"
            return
        else
            throw 'clipboard not found!'
        endif
        system(cmd, @")
    else
        system(cmd, @")
    endif
enddef

def ClipboardPaste(cmd_: string)
    var cmd = cmd_
    if empty(cmd)
        if executable('pbpaste')
            cmd = 'pbpaste'
        elseif has('clipboard')
            @" = @+
            return
        else
            throw 'clipboard not found!'
        endif
        @" = system(cmd)
    else
        @" = system(cmd)
    endif
enddef

# execute current line (or select lines), comment removed {{{2
nnoremap <Leader><CR> :call <SID>ExecuteLines('n')<CR>
vnoremap <Leader><CR> :<C-u>call <SID>ExecuteLines('v')<CR>

def ExecuteLines(mode: string)
    var lines: list<string>
    if mode == 'n'
        lines = [getline('.')]
    elseif mode == 'v'
        var t = @"
        silent normal gvy
        lines = split(@", "\n")
        @" = t
    endif
    var result_l = []
    for i in lines
        result_l = add(result_l, substitute(i, '\v^\s*(//|#|"|--)+', '', ''))
    endfor
    var result: string = join(result_l, "\n")
    echom result
    echo 'execute? y/N '
    if nr2char(getchar())->tolower() == 'y'
        redraws
        try
            execute result
        finally
        endtry
    else
        redraws | echon 'cancelled.'
    endif
enddef

# switch number / relativenumber {{{2
nnoremap <silent> <Leader>n :call <SID>Switch_nu_rnu()<CR>

def Switch_nu_rnu()
    # no [0, 1]
    const presents = [[1, 1], [1, 0], [0, 0], [1, 1]]
    ->mapnew((_, i) => [i[0] == 1, i[1] == 1])
    const idx = index(presents, [&l:nu, &l:rnu])
    [&l:nu, &l:rnu] = presents[idx + 1]
enddef

# switch quickfix window (open / focus or close) {{{2
nnoremap <silent> <Leader>q :call <SID>SwitchQuickfixWindow()<CR>

def SwitchQuickfixWindow()
    if &ft == 'qf'
        cclose
    else
        execute 'bot' 'copen' &cwh
    endif
enddef

# snippet; :Scratch [filetype] / :ScratchNew [filetype] (with new window) {{{2
command -nargs=? -complete=filetype Scratch Scratch(<q-args>)
command! -nargs=? -complete=filetype ScratchNew SnippetInNewWindow(<q-args>)

def Scratch(ft: string)
    enew | setl buftype=nofile noswapfile bufhidden=hide
    if !empty(ft)
        exe 'setl ft=' .. ft
    endif
enddef

def SnippetInNewWindow(ft: string)
    exe printf('bel :%dnew', &cwh)
    setl buftype=nofile noswapfile
    setl bufhidden=hide
    if !empty(ft)
        exe 'setl ft=' .. ft
    endif
enddef

# run vim command; :KvimRun {vim_command}... {{{2
command! -nargs=+ -complete=command KvimRun ShowOutput(execute(<q-args>))

# vim expr; :KvimExpr {vim_expr}... {{{2
command! -nargs=+ -complete=expression KvimExpr ShowOutput(eval(<q-args>))

def ShowOutput(data: string)
    ScratchNew
    for line in split(data, "\n")
        append('$', line)
    endfor
    norm gg"_dd
enddef

# insert shebang based on filetype; :KshebangInsert [content after "#!/usr/bin/env "] {{{2
command! -nargs=* -complete=shellcmd KshebangInsert ShebangInsert(<q-args>)

g:vimrc_shebang_lines = {
    'awk': '/usr/bin/awk -f', 'javascript': 'node', 'lua': 'lua',
    'perl': 'perl', 'python': 'python', 'ruby': 'ruby',
    'scheme': 'scheme-run', 'sh': '/bin/sh', 'zsh': 'zsh',
    }

def ShebangInsert(args: string)
    const first_line = getline(1)
    if len(first_line) >= 2 && first_line[0 : 1] == '#!'
        throw 'shebang exists!'
    endif
    var shebang: string
    if !empty(args)
        shebang = args
    elseif has_key(g:vimrc_shebang_lines, &ft)
        shebang = g:vimrc_shebang_lines[&ft]
    else
        throw 'shebang: which interpreter to run?'
    endif
    if match(shebang, '^/') >= 0
        shebang = '#!' .. shebang
    else
        shebang = '#!/usr/bin/env ' .. shebang
    endif
    # insert at first line and leave cursor here (for further modification)
    normal ggO<Esc>
    var ret = setline(1, shebang)
    if ret == 0  # success
        normal $
    else
        throw 'setting shebang error!'
    endif
enddef

# match long line; :KmatchLongLine {number} {{{2
# Refer: https://stackoverflow.com/a/1117367
command! -nargs=1 KmatchLongLine exe ':/\%>' .. <args> .. 'v.\+'

# `J` with custom seperator; <visual>:J sep... {{{2
command! -nargs=1 -range J JoinLines(<q-args>)
def JoinLines(sep: string)
    const buf = @"
    try
        norm gv
        norm x
        @" = substitute(@", "\n", sep, 'g')
        norm P
    finally
        @" = buf
    endtry
enddef

# edit selected line / column; :Kjump {{{2
command! -nargs=+ Kjump JumpToLineCol(<args>)
def JumpToLineCol(line: number, col: number = 0)
    execute 'normal' line .. 'gg'
    if col > 1
        execute 'normal 0' .. (col - 1) .. 'l'
    endif
enddef

# Selection() {{{2
def g:Selection(): string
    const tmp = @"
    var result = ''
    var success = false
    try
        silent normal gvy
        success = true
    finally
        result = @"
        @" = tmp
        if !success
            throw 'g:Selection() failed!'
            # make type check happy.
            return result
        else
            return result
        endif
    endtry
enddef

# :SetCmdText / SetCmdText() {{{2
def g:SetCmdText(text: string)
    feedkeys(':' .. text, 't')
enddef

command! -nargs=+ SetCmdText g:SetCmdText(<q-args>)

# `*` / `#` in visual mode (like `g*` / `g#`); dep: Selection() {{{2
vnoremap <silent> * :<C-u>call feedkeys('/\V' .. substitute(escape(Selection(), '\/'), "\n", '\\n', 'g') .. "\n", 't')<CR>
vnoremap <silent> # :<C-u>call feedkeys('?\V' .. substitute(escape(Selection(), '\/'), "\n", '\\n', 'g') .. "\n", 't')<CR>

# :KqutebrowserEditCmd {{{2
if !empty($QUTE_FIFO)
    command! KqutebrowserEditCmd KqutebrowserEditCmd()

    def KqutebrowserEditCmd()
        setl buftype=nofile noswapfile
        setline(1, $QUTE_COMMANDLINE_TEXT[1 :])
        setline(2, '')
        setline(3, 'hit `<Space>q` to save cmd (first line) and quit')
        # weired bug with `map ... \| q...` in vim9script.
        legacy nnoremap <buffer> <Space>q :call writefile(['set-cmd-text -s :' .. getline(1)], $QUTE_FIFO) \| q<CR>
    enddef
endif

# :Tmux {{{2
if exists("$TMUX")
    command! -nargs=1 -bar Tmux TmuxOpenWindow(<q-args>)

    def TmuxOpenWindow(args: string)
        const options = {'c': 'neww', 's': 'splitw -v', 'v': 'splitw -h'}
        var ch = match(args, '\s')
        var option: string
        var args: string
        if ch == -1
            [option, args] = [a:args, '']
        else
            [option, args] = [a:args[:ch], a:args[ch:]]
        endif
        option = get(options, trim(option))
        if empty(option)
            throw 'unknown option: ' .. args .. '; valid: ' .. join(keys(options), ' / ')
        endif
        call system("tmux " .. option .. " -c " .. shellescape(getcwd()) .. args)
    enddef
endif

# Cd <path> / :Cdalternate / :Cdhome / :Cdbuffer / :Cdproject [:]cmd... {{{2
command! -nargs=1 -complete=dir Cd Cd('', <q-args>)
command! -nargs=* -complete=command Cdalternate Cd('alternate', <q-args>)
command! -nargs=* -complete=command Cdhome Cd('home', <q-args>)
command! -nargs=* -complete=command Cdbuffer Cd('buffer', <q-args>)
command! -nargs=* -complete=command Cdproject Cd('project', <q-args>)

def Cd(flag: string, args: string)
    var cmd = args
    var path: string
    if flag == 'alternate'
        path = fnamemodify(bufname('#'), '%:p:h')
    elseif flag == 'home'
        path = expand('~')
    elseif flag == 'project'
        path = Cd_get_project_dir()
    elseif flag == 'buffer'
        path = Cd_get_buf_dir()
    else
        if args =~ '^:'
            throw 'path argument is required!'
        endif
        # Cd: split argument as path & cmd
        path = substitute(args, '\v^(.{}) :.+$', '\1', '')
        cmd = args[len(path) + 1 :]
    endif

    if !isdirectory(path)
        path = expand(path)
    endif
    if !isdirectory(path)
        path = fnamemodify(path, ':h')
    endif
    if !isdirectory(path)
        throw 'not a directory: ' .. args
    endif

    if !empty(cmd)
        var old_cwd = getcwd()
        var buf = bufnr('')
        try
            # use buffer variable to store cwd if `exe` switch to new window
            b:vimrc_old_cwd = old_cwd
            silent exe 'lcd' fnameescape(path)
            exe cmd
        finally
            if buf == bufnr('')
                if exists('b:vimrc_old_cwd')
                    unlet b:vimrc_old_cwd
                endif
                silent exe 'lcd' fnameescape(old_cwd)
            endif
        endtry
    else
        silent exe 'lcd' fnameescape(path)
        if &buftype == 'terminal'
            term_sendkeys(bufnr(''), 'cd ' .. shellescape(path))
        endif
    endif
enddef

augroup vimrc
    au BufEnter * {
        # reset cd
        if exists('b:vimrc_old_cwd')
            try
                silent exe 'lcd' fnameescape(b:vimrc_old_cwd)
            finally
                unlet b:vimrc_old_cwd
            endtry
        endif
        }
augroup END

def Cd_get_buf_dir(): string
    var path = expand('%:p:h')
    if empty(path) || &buftype == 'terminal'
        path = getcwd()
    endif
    return path
enddef

def Cd_get_project_dir(): string
    var path = Cd_get_buf_dir()
    var parent: string
    while 1
        if isdirectory(path .. '/.git')
            return path
        endif
        if filereadable(path .. '/.git')
            # git submodule
            return path
        endif
        parent = fnamemodify(path, ':h')
        if path == parent
            return ''
        endif
        path = parent
    endwhile
    # unrechable
    return path
enddef

# terminal-api related user function {{{2
# sync terminal path to buffer path.
# TODO follow cd even when terminal buffer not in focus (with event?).
def g:Tapi_cd(nr: number, arg: list<string>)
    if bufnr() == nr
        var p = arg[0]
        if is_win32 && match(p, '^/') >= 0
            p = execute(printf("Sh cygpath -w '%s'", substitute(p, "'", "'\\\\''", 'g')))
        endif
        silent execute 'lcd' fnameescape(p)
    endif
enddef

# :Jobrun / :Jobqfrun / :Jobstop / :Joblist / :Jobclear {{{2
command! -range=0 -nargs=+ Jobrun
| JobRun(<q-args>, {range: <range>, line1: <line1>, line2: <line2>, qf: false})
command! -range=0 -nargs=+ Jobqfrun
| JobRun(<q-args>, {range: <range>, line1: <line1>, line2: <line2>, qf: true})
command! -nargs=* -bang -complete=custom,JobStopComp Jobstop
| JobStop(<q-args>, <bang>0 ? 'kill' : 'term')
command! Joblist call JobList()
command! -count Jobclear call JobClear(<count>)

var job_dict = exists('job_dict') ? job_dict : {}

def JobOutCb(ctx: dict<any>, _: channel, msg: string)
    const buf = ctx.bufnr
    setqflist([], 'a', {nr: buf, lines: [msg]})
enddef

def JobExitCb(ctx: dict<any>, job: job, ret: number)
    const buf = ctx.bufnr
    var data = []
    add(data, '')
    add(data, '===========================')
    add(data, 'command finished with code ' .. ret)
    if ctx.qf
        setqflist([], 'a', {nr: buf, lines: data})
    else
        appendbufline(buf, '$', data)
    endif
enddef

def JobRun(cmd_a: string, opt: dict<any>)
    if exists(':Sh') != 2
        throw 'depends on vim-sh plugin!'
    endif
    if exists(':ScratchNew') != 2
        throw 'depends on `:ScratchNew`!'
    endif
    var cmd: string = cmd_a
    var flag: string = '-n'
    if match(cmd, '^-') >= 0
        var tmp = matchlist(cmd, '\v^(-\S+)\s+(.*)$')
        cmd = tmp[2]
        flag = tmp[1] .. 'n'
    endif
    var cmd_short = cmd
    if opt.range != 0
        cmd = printf(':%s,%sSh %s %s', opt.line1, opt.line2, flag, cmd)
    else
        cmd = printf('Sh %s %s', flag, cmd)
    endif
    var job_d = json_decode(execute(cmd))
    var bufnr: number
    if opt.qf
        var current_max = getqflist({nr: '$'}).nr
        bufnr = current_max + 1
        setqflist([], ' ', {title: '(:Joblist to check state) ' .. cmd_short, nr: bufnr})
        extend(job_d.opt, {
            out_cb: function(JobOutCb, [{bufnr: bufnr}]),
            err_cb: function(JobOutCb, [{bufnr: bufnr}]),
            })
    else
        ScratchNew
        bufnr = bufnr()
        wincmd p
        extend(job_d.opt, {
            out_io: 'buffer', err_io: 'buffer',
            out_buf: bufnr, err_buf: bufnr,
            })
    endif
    extend(job_d.opt, {
        exit_cb: function(JobExitCb, [{bufnr: bufnr, qf: opt.qf}]),
        })

    extend(job_dict, {
        [bufnr]: {
            job: job_start(job_d.cmd, job_d.opt),
            cmd: cmd_short,
            }
        })
enddef

def JobStop(id_a: string, sig: string)
    var id = empty(id_a) ? bufnr() : str2nr(matchstr(id_a, '\v^\d+'))
    if has_key(job_dict, id)
        job_stop(job_dict[id].job, sig)
    else
        throw 'job not found: buffer id ' .. id
    endif
enddef

def JobStopComp(...arg: list<any>): string
    var result = []
    for [k, v] in items(job_dict)
        if v.job->job_status() == 'run'
            add(result, printf('%s: %s', k, v.cmd))
        endif
    endfor
    return join(result, "\n")
enddef

def JobList()
    for [k, v] in items(job_dict)
        echo printf("%s:\t%s\t%s", k, v.job, v.cmd)
    endfor
enddef

def JobClear(num: number)
    for item in num > 0 ? [num] : keys(job_dict)
        var job = get(job_dict, item)
        if !empty(job)
            if job.job->job_info().status != 'run'
                remove(job_dict, item)
            endif
        endif
    endfor
enddef

# :Mpc {{{2
if executable('mpc')
    command! Mpc Mpc()

    var mpc_prop_type = 'song'

    def Mpc()
        enew | setl filetype=mpc buftype=nofile noswapfile nobuflisted
        var buf = bufnr()
        prop_type_add(mpc_prop_type, {bufnr: buf})
        var i = 1
        for line in split(system('mpc playlist'), "\n")
            setline(i, line)
            prop_add(i, 1, {type: mpc_prop_type, id: i, bufnr: buf})
            i += 1
        endfor
        const nr = str2nr(system('mpc current -f "%position%"'))
        execute 'norm' nr .. 'G'
        nnoremap <buffer> <silent> <CR> <cmd>call <SID>MpcPlay()<CR>
    enddef

    def MpcPlay()
        var props = prop_list(line('.'))
        if len(props) == 0
            return
        endif

        var prop = props[-1]
        if prop['type'] == mpc_prop_type
            job_start(printf('mpc play %d', prop.id))
        endif
    enddef
endif

# :ChdirTerminal [path]; default path: selection / <cfile>; expand() is applied; use existing terminal if possible; bang: using Sh -w (default: Sh -t) {{{2
# depends on g:Selection().
command! -bang -nargs=* -range=0 ChdirTerminal ChdirTerminal(<bang>false, <range>, <q-args>)

def ChdirTerminal(bang: bool, range: number, path_a: string)
    var path = path_a ?? ( range > 0 ? g:Selection() : expand('<cfile>') )
    if match(path, '\v^[~$<%]') >= 0
        path = expand(path)
    endif
    path = fnamemodify(path, ':p')
    if filereadable(path)
        path = fnamemodify(path, ':h')
    endif
    if !isdirectory(path)
        throw 'is not directory or not readable: ' .. path
    endif

    const bufs: list<number> = tabpagebuflist()
    if !bang
        for i in term_list()->filter(
            (_, x) => x->term_getstatus() == 'running'
            )
            const idx: number = index(bufs, i)
            if idx >= 0
                echo printf('chdir in window [%d]? [y/N] ', idx + 1)
                if nr2char(getchar())->tolower() == 'y'
                    execute ':' .. (idx + 1) 'wincmd w'
                    call feedkeys(printf('%scd %s', mode() == 'n' ? 'i' : '', shellescape(path)), 't')
                else
                    redrawstatus | echon 'cancelled.'
                endif
                return
            endif
        endfor
    endif
    const cmd = bang ? 'Sh -w' : 'Sh -t'
    execute 'Cd' path ':' .. cmd
enddef

# g:Popup(cmd: string, Cb: fn<list<string>>, ctx : dict = {}); {{{2

# variable used in popup terminal;
var popup_tmpfile: string = ''
var popup_win: number

# variable used in Sh -w popup program;
var tmpfiles_dict: dict<func> = {}

def g:Popup(cmd: string, Cb: func, ...args: list<dict<any>>)
    var exec_pre: string = 'exec'
    var range: string = ''
    var kwargs: dict<any> = args->get(0) ?? {}
    if kwargs->has_key('input') || kwargs->has_key('ex')
        const stdin_f: string = tempname()
        if kwargs->has_key('input')
            writefile(kwargs.input->split("\n"), stdin_f)
        else
            writefile(execute(kwargs.ex)->split("\n"), stdin_f)
        endif
        exec_pre ..= (' < ' .. shellescape(stdin_f))
    endif
    if kwargs->get('range', 0) > 0
        range = printf(':%d,%d', kwargs.line1, kwargs.line2)
    endif
    var tmpfile: string = tempname()
    exec_pre ..= (' > ' .. shellescape(tmpfile))
    var res: dict<any> = json_decode(execute(printf('%sSh -n %s; %s', range, exec_pre, cmd)))

    # use Sh -w as popup, then we set tmpfiles_dict.
    if kwargs->has_key('program')
        const program: string = kwargs.program
        if match(program, '\v[^a-z]') >= 0
            throw printf('invalid program: "%s"', program)
        endif

        if !exists('g:vimserver_env')
            || match(get(g:vimserver_env, 'VIMSERVER_BIN', '.sh'), '\v\.sh$') >= 0
            throw 'vimserver-helper (.exe) not available!'
        endif

        var exe: string = g:vimserver_env['VIMSERVER_BIN']
        var server: string = g:vimserver_env['VIMSERVER_ID']

        tmpfiles_dict[tmpfile] = Cb
        exe = shellescape(exe)
        server = shellescape(server)
        tmpfile = shellescape(tmpfile)
        var title: string = kwargs->get('title', '') ?? 'Selection'
        if match(title, '\v[^a-zA-Z_-]') >= 0
            # Sh -title=xxx does not accept too many type of char.
            title = 'Selection'
        endif
        execute(printf("%sSh -c,w=%s,title=%s %s; sh -c '\"$@\" && %s %s %s %s' - %s",
        range, program, title, exec_pre,    exe, server, 'Tapi_popup_cb', tmpfile, cmd))
        # exit now!
        return
    endif

    # use builtin popup, then tmpfile can be set safely.
    # (popup terminal steals focus).
    popup_tmpfile = tmpfile
    var buf = term_start(res.cmd, extendnew(res.opt, {exit_cb: function(TermExitCb), hidden: 1}))
    const width: number = min([&columns - 10, 80])
    const height: number = min([&lines - 5, 24])
    popup_win = popup_create(buf, {
        minwidth: width, maxwidth: width, minheight: height, maxheight: height,
        callback: function(PopupCloseCb, [Cb])
        })
enddef

def TermExitCb(_: job, code: number)
    popup_close(popup_win, code == 0 ? readfile(popup_tmpfile) : [])
enddef

def PopupCloseCb(Cb: func, _: number, result: list<string>)
    # TODO is this check required?
    if !empty(result)
        call(Cb, [result])
    endif
enddef

# it will be called from g:Tapi_popup_cb (also defined in this file).
def PopupCallback(tmpfile: string)
    if tmpfiles_dict->has_key(tmpfile)
        # -1 is random.
        # TODO check exitcode? (seems not necessary)
        PopupCloseCb(tmpfiles_dict[tmpfile], -1, readfile(tmpfile))
        remove(tmpfiles_dict, tmpfile)
    endif
enddef

# :Select {buffer|filelist|color} {{{2
command! -nargs=1 -range=0 -complete=custom,SelectComp Select
| Select(<q-args>, {range: <range>, line1: <line1>, line2: <line2>})

# platform dependent setting
# TODO win32: check if tty is available (conpty or winpty)
const ctx_use_w_program: bool = is_win32

# Select() and it's comp {{{3
def SelectComp(..._: list<any>): string
    return popup_sources->keys()->join("\n")
enddef

def Select(source: string, ctx: dict<any>)
    if popup_sources->has_key(source)
        call(popup_sources[source], [ctx])
    else
        throw printf('selection not implemented: "%s"!', source)
    endif
enddef

# buffers / LsBuffers() {{{3
def LsBuffers(ctx: dict<any>)
    g:Popup(
    'fzf',
    (s: list<string>) => {
        const bufnr = s[0]->matchstr('\v^\s*\zs(\d+)\ze')
        execute ':' .. bufnr .. 'b'
        },
    extendnew({ex: 'ls', title: 'select-buffer'},
    ctx_use_w_program ? {program: 'cmd'} : {}),
    )
enddef

# color / Color() {{{3
def Color(ctx: dict<any>)
    g:Popup(
    'fzf',
    (s: list<string>) => {
        execute 'color' fnameescape(s[0])
        },
    extendnew({
    title: 'select-color',
    input: globpath(&rtp, "colors/*.vim", 0, 1)
    ->mapnew((_, i) => i->split('[\/.]')->get(-2))->join("\n")
    },
ctx_use_w_program ? {program: 'cmd'} : {}),
)
enddef

# filelist / FileList() {{{3
def FileList(ctx: dict<any>)
    if ctx.range == 0
        throw 'range is required!'
    endif
    g:Popup(
    'fzf',
    (s: list<string>) => {
        execute 'e' fnameescape(s[0])
        },
    extendnew(
    extendnew(ctx, {title: 'select-filelist'}),
    ctx_use_w_program ? {program: 'cmd'} : {}),
    )
enddef

# register new source here! {{{3
const popup_sources: dict<func> = {
    buffer: LsBuffers,
    color: Color,
    filelist: FileList,
    }

# g:Tapi_popup_cb() {{{3
def g:Tapi_popup_cb(nr: number, arg: list<string>)
    const tmpfile = arg->get(0, '')
    if !empty(tmpfile)
        PopupCallback(tmpfile)
    endif
enddef

# sv() helper (in vim embedded terminal) {{{2
def g:Tapi_shell_sv_helper(...arg: list<any>)
    feedkeys("\<C-space>")
enddef

# <c-n> / <c-p> to switch buffer. {{{2
nnoremap <C-n> <cmd>call <SID>SwitchBuffer(v:true)<CR>
nnoremap <C-p> <cmd>call <SID>SwitchBuffer(v:false)<CR>
def SwitchBuffer(reverse: bool = false)
    var current: number = bufnr()

    const single_window: bool = tabpagebuflist()->len() == 1
    if !single_window
        tabe
    endif

    const all_bufs = getbufinfo()
    ->filter((_, i) => !empty(i.name) && !empty(i.listed))
    ->mapnew((_, i) => i.bufnr)

    if empty(all_bufs)
        # avoid divide zero
        return
    endif

    var idx = index(all_bufs, current)
    if idx < 0 && reverse
        idx = 0
    endif
    if single_window
        idx += (reverse ? 1 : -1)
    endif
    idx = idx % len(all_bufs)

    execute ':' string(all_bufs[idx]) 'b'
enddef

# :Rg {...} {{{2
# TODO qf: support chdir (like :Cdb ...);
# TODO qf: support stdin;
command! -range -nargs=+ -complete=file Rg
| Rg(<q-args>, {range: <range>, line1: <line1>, line2: <line2>})

def Jumpback(buf: number)
    const buffers = tabpagebuflist()
    const idx = index(buffers, buf)
    if idx >= 0
        execute 'normal' (idx + 1) "\<Plug>(jump_to_file)"
    else
        echoerr 'buffer not found!'
    endif
enddef

def Rg(arg: string, opt: dict<any>)
    const buf = bufnr()
    if opt.range == 0
        exec 'Jobqfrun' 'rg --vimgrep' arg
        # jump to qf window. (<Leader>q defined in this file.)
        feedkeys(' q', 't')
    else
        var result: string = execute(
        printf(':%d,%dSh rg -I --column %s', opt.line1, opt.line2, arg)
        )
        if opt.line1 != 1
            # if range is not % (line number will be wrong), fix it.
            result = result
            ->split("\n")
            ->map((_, i) => {
                var res = i
                const colon: number = match(res, ':')
                if colon >= 0 && res[0 : colon - 1] =~ '\v^\d+$'
                    res = string(str2nr(res[0 : colon - 1]) + opt.line1 - 1) .. res[colon : ]
                endif
                return res
                })
            ->join("\n")
        endif

        bel :7sp +enew | setl buftype=nofile
        put =result
        norm gg"_dd
        execute printf("nnoremap <buffer> <CR> <cmd>call <SID>Jumpback(%s)<CR>", buf)
        execute printf("nnoremap <buffer> <C-j> <cmd>call <SID>Jumpback(%s)<CR><C-w>p", buf)
        syn match String '\v^[0-9]+'
    endif
enddef

# exe {{{2
augroup vimrc
    au BufReadCmd *.exe,*.dll ReadBin(expand('<amatch>'))
    au BufWriteCmd *.exe,*.dll WriteBin(expand('<amatch>'))
augroup END

# avoid using busybox xxd.
const xxd_path = exists($VIM .. '/bin/xxd') ? '"$VIM"/bin/xxd' : 'xxd'

def ReadBin(name: string)
    execute printf('silent r !%s %s', xxd_path, shellescape(name))
    normal gg"_dd
enddef

def WriteBin(name: string)
    if is_win32
        # returncode check is ignored.
        job_start('xxd -r', {in_io: 'buffer', in_buf: bufnr(), out_io: 'file', out_name: name})
    else
        execute printf(':%w !%s -r > %s', xxd_path, shellescape(name))
        if !empty(v:shell_error)
            return
        endif
    endif
    setl nomodified
    redrawstatus | echon 'written.'
enddef

# TODO shortcut for reader mode. (view code / text easily.) {{{2

# finish {{{1 }}}1
