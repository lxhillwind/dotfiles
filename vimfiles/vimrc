if !has('vim9script') | throw 'vim9script feature not detected!' | endif
vim9script noclear
# :packadd! (as early as possible) {{{1
set pp^=~/vimfiles

# vim-vimserver should be called early.
packadd vim-vimserver

# disable default plugin {{{
g:loaded_2html_plugin = 1
g:loaded_getscriptPlugin = 1
g:loaded_gzip = 1
g:loaded_logiPat = 1
g:loaded_netrwPlugin = 1
g:loaded_tarPlugin = 1
g:loaded_vimballPlugin = 1
g:loaded_zipPlugin = 1  # }}}

g:tasks_config_paths =<< trim END
    ~/vimfiles/config/tasks.ini
    ~/vimfiles/config/tasks-local.ini
END
g:tasks_config_paths
    ->map((_, i) => expand(i))
    ->filter((_, i) => filereadable(i))

g:markdown_folding = 1
g:markdown_fenced_languages = [
    'awk', 'python', 'sh', 'vim',
    'c', 'go', 'javascript',
    'dosini', 'json', 'yaml',
    'zig',
]

# use matchit, so vim9 filetype indent work as expected.
# https://github.com/vim/vim/issues/7628
packadd! matchit

packadd! vim-fuzzy
packadd! securemodelines
packadd! vim9-syntax
packadd! vim-tridactyl

packadd! vim-dirvish
g:loaded_netrwPlugin = 1

packadd! vim-sneak
g:sneak#label = 1
# sneak unmap f / t when one of them is pressed after sneak key. {{{
# MRE:
#   :map t <Nop><CR>
#   sssff
#   :map t
# then mapping for t disappeared.
#
# since I only map t / T (f / F not mapped), only set t / T below.
# }}}
g:sneak#f_reset = 1
g:sneak#t_reset = 0
# I do not use vim-surround, so preserve s / S for vim-sneak.
vmap S <Plug>Sneak_S
omap s <Plug>Sneak_s
omap S <Plug>Sneak_S

packadd! vim-markdown-folding
g:markdown_fold_style = 'nested'
g:markdown_fold_override_foldtext = 0

# colorscheme
packadd! sitruuna.vim

# completion {{{2
# source for dictionary, current or other loaded buffers, see ':help cpt'
set cpt=.,k,w,b
# don't select the first item.
set completeopt=menu,menuone,noselect
# suppress annoy messages.
set shortmess+=c

# disable its imap <Tab> (and some others)
g:mucomplete#enable_auto_at_startup = 1
g:mucomplete#no_mappings = 1
# disable keyn / dict: included in c-n via option 'complete' ('cpt');
# about these chains description: help 'mucomplete-methods'
g:mucomplete#chains = {
    default: ['path', 'omni', 'user', 'c-n', 'uspl'],
    vim:     ['path', 'cmd',  'user', 'c-n', 'uspl'],
    # sql: disable omni, since it causes trouble. (sth missing?)
    sql:     ['path',         'user', 'c-n', 'uspl'],
}

var coc_nvim_available = false
if !empty($VIMRC_USING_COC)
    try
        # must-have extensions:
        # :CocInstall coc-json coc-pairs
        packadd! coc.nvim
        coc_nvim_available = true
    catch /^Vim\%((\a\+)\)\=:E919:/
    endtry
    if !coc_nvim_available
        echoerr 'unable to find coc.nvim'
    endif
endif

if !coc_nvim_available
    packadd! vim-mucomplete
    imap <expr> <Tab> (pumvisible() ? "\<plug>(MUcompleteCycFwd)" : "\<plug>(MUcompleteFwd)")
    imap <expr> <S-Tab> (pumvisible() ? "\<plug>(MUcompleteCycBwd)" : "\<plug>(MUcompleteBwd)")
    # make <CR> always add newline.
    inoremap <expr> <cr> pumvisible() ? "<c-y><cr>" : "<cr>"

    packadd! vim-dict
    # always enable dict completion. (i_<Ctrl-x><Ctrl-k>)
    execute 'set dict+=' .. globpath(&rtp, 'dict/text.dict', 0, 1)->get(0, '')->fnameescape()
endif
# "filetype plugin indent on" {{{1
# - plugin loading should be put **before** this. (see :help packadd)
# - filetype related autocmd should be put **after** this.
filetype plugin indent on
if !exists('g:syntax_on')
    syntax on
endif
# internal helper function. {{{1
# expand() should NOT be used to expand arbitrary file (like containing
# "[b-a]" in filename).
def ExpandHead(s: string): string
    if match(s, '\v^[%#<]') == 0
        return expand(s)
    elseif match(s, '\v^\~') == 0
        return expand('~') .. s[1 : ]
    elseif match(s, '\v^\$\ze[a-zA-Z_]') == 0
        const idx = match(s, '\v([^a-zA-Z_]|$)', 1)
        return expand(s[: idx - 1]) .. s[idx : ]
    endif
    return s
enddef

def g:ExpandHead(s: string): string
    return ExpandHead(s)
enddef

def TrSlash(s: string): string
    if has('win32')
        return substitute(s, '\', '/', 'g')
    else
        return s
    endif
enddef

# Source() function is like ":source arg", except that arg is append to
# vimrc's directory.
def Source(file: string)
    execute 'source' fnameescape(vimrc_dir .. '/' .. file)
enddef
const vimrc_dir = expand('<sfile>')->fnamemodify(':h')
# common definition {{{1
const is_unix = has('unix')
const is_win32 = has('win32')
const has_gui = has('gui_running') || has('mac')
|| (has('linux') && (!empty($DISPLAY) || !(empty($WAYLAND_DISPLAY))))
const is_linux = has('linux')
const is_mac = has('mac')
const is_wsl = executable('/mnt/c/Windows/notepad.exe')

g:fuzzy#config = exists('g:fuzzy#config') ? g:fuzzy#config : {}
augroup vimrc
    au!
augroup END
# vimrc detection. {{{1
# Error if reading system-vimrc. {{{
# Some distribution's system-vimrc (like openSUSE) does sth,
# like set mapping, add autocmd.
# Some of these settings are good, but we want to keep these setting in vimrc
# (so it works for other distribution).
# To avoid duplicate setting, we just disable loading system-vimrc.
#
# Suggestion: put `exec /usr/bin/vim -Nu ~/vimfiles/vimrc "$@"` in ~/bin/vim,
# and add ~/bin in $PATH (before /usr/bin), so ~/bin/vim wins.
#
# In some environment (like git-for-windows), it is hard to put custom vim in
# $PATH.
# set vim variable g:vimrc_allow_system or env VIMRC_ALLOW_SYSTEM to 1 to skip check.
#
# Inspection of some distros' system vimrc:
#   git-for-windows:
#     - add autocmd to recover jump; safe to duplicate.
#   openSUSE:
#     - autocmd to recover jump (it's ok);
#     - some key mapping to cause <Ctrl-[> delay, this is not acceptable!
# }}}
const first_vimrc = execute('scr')->split("\n")->get(0)
            ->substitute('\v^.{-}:\s*', '', '')
            ->ExpandHead()
            ->TrSlash()

if has('vim_starting') && exists('$MYVIMRC') && first_vimrc != TrSlash($MYVIMRC)
    if !(
        !empty(get(g:, 'vimrc_allow_system'))
        || !empty($VIMRC_ALLOW_SYSTEM)
        )
        throw 'system-vimrc is read. skip loading vimrc!'
    endif
endif

if !exists('$MYVIMRC')
    # If we use `vim -u ...`, $MYVIMRC will not be set.
    # make ":e $MYVIMRC" work.
    $MYVIMRC = first_vimrc
endif
# config compatible with vim tiny version. {{{1
Source('./rc/tiny.vim')
# option {{{1
# &rtp {{{2
# why not using = here? since we may want to add package before souring this
# file; `set rtp=XXX` here will cause problem.
set rtp^=~/vimfiles

# add ~/bin to $PATH {{{2
# Even when set ~/bin in $PATH via ~/.config/zshrc, it may not be added when
# invoking gvim from desktop session, then ":sh" / ":Sh" / ":term" may not
# work for command defined in ~/bin.
# So add it to $PATH in vim explicitly.
const env_path_sep = is_win32 ? ';' : ':'
const home_bin = expand('~/bin')
if index($PATH->split(env_path_sep), home_bin) < 0
    $PATH = home_bin .. env_path_sep .. $PATH
endif

# win32 environment prepare {{{2
if is_win32 && has('vim_starting')
    Source('./rc/win32.vim')
endif

# unnamed... {{{2
# set leader / localleader to unused key, so plugin is hardly to clash with
# our key.
# Refer: lacygoill's vimrc.
g:mapleader = "\<S-F10>"
g:maplocalleader = "\<S-F11>"

# use <Space> as *true* leader key.
noremap <Space> <Nop>
#nnoremap <Space><Space> :nmap <Char-60>Space<Char-62><CR>
# this looks better: vim-fuzzy mapping (n).
nmap <Space><Space> <Space>fmn
nnoremap <Space>;; :map <buffer><CR>

# shell {{{2
# 'shelltemp' or 'noshelltemp': {{{
# - In win32 gui, 'noshelltemp' makes ":!" and ":[range]w !" work like in unix:
# no external cmd window;
# (if guioptions contain '!', ":!" will not show cmd window anyway.)
#
# but encoding cannot be detected (e.g. in "r !")
#
# - In unix, 'noshelltemp' makes ":[range]w !" not create tempfile;
#
# but if guioptions contain '!', ":r !" would not write content to buffer.
#
# So do not change 'shelltemp' option (default on).
# }}}

if is_unix
    const zsh_path = is_mac ? '/opt/homebrew/bin/zsh' : '/bin/zsh'
    if executable(zsh_path)
        &shell = zsh_path
    endif
endif

# cmdline completion {{{2
# defined here instead of legacy, since it is available only after version 8.x
set wildoptions=pum,fuzzy

# builtin terminal enhancement {{{2
def TerminalPaste()
    echo @"
    if @"[-1 : ] == "\n"
        echohl WarningMsg
        echo '<Newline> at end!'
        echohl NONE
    endif
    echo 'paste in terminal? (cursor may be at wrong place!) [y/N] '
    if tolower(nr2char(getchar())) == 'y'
        feedkeys("i\<C-w>" .. '""', 'n')
        redraws | echon 'pasted.'
    else
        redraws | echon 'cancelled.'
    endif
enddef

# define a function, so it can also be used in popup terminal.
def TerminalSetup()
    if &buftype != 'terminal'
        return
    endif
    setl nonu | setl nornu
    # plugin/jump.vim
    nmap <buffer> <CR> <Plug>(jump_to_file)
    vmap <buffer> <CR> <Plug>(jump_to_file)
    # clipboard
    nnoremap <buffer> p :<C-u>call <SID>TerminalPaste()<CR>
    nnoremap <buffer> P :<C-u>call <SID>TerminalPaste()<CR>
    # dirvish
    if exists(':Dirvish') == 2
        nnoremap <buffer> - <Cmd>execute 'Dirvish' fnameescape(getcwd())<CR>
    endif
    # <C-w> as in terminal.
    tnoremap <buffer> <C-w> <C-w>.
enddef

augroup vimrc
    au TerminalWinOpen * TerminalSetup()
augroup END

# statusline {{{2
set ruler
&rulerformat = '%20('
.. '%M'
.. ' <%B>'
.. ' %l:%{charcol(".")}%V'
.. '%='
.. '%P'
.. '%)'

# viminfo {{{2
# &viminfo should be set with ^= (the first match will be used) {{{
# according to source code.
# (in file src/viminfo.c, function find_viminfo_parameter())
#
# if option is already present (like '1000), reset (like :so $MYVIMRC) would
# do nothing.
# }}}
set viminfo^='1000

# set locale {{{2
if is_unix
    # some environment cannot set lang, like in minimal container (fedora).
    silent! lang en_US.UTF-8
else
    # for msys2 / git-for-windows, set $LANG to make CJK display correctly.
    $LANG = 'en_US.UTF-8'
    # when libintl.dll is not available, message translation is disabled.
    # so no need to set "$LANG = 'en'". (see :help win32-gettext)
endif

# foldmethod {{{2
# it's too easy to use vim style folder in various text file.
# just set fdm=marker as default.
if has('vim_starting')
    set fdm=marker
endif

# sessionoptions; better ":mksession" option. {{{2
# do not include options in ssop; {{{
# since it breaks mapping with <ScriptCmd>. (like vim-fuzzy)
# Maybe we can use other way to dump mapping.
# }}}
set ssop=blank,curdir,folds,help,tabpages,winsize,terminal

# various vim dir & file {{{2
# copy from https://github.com/mhinz/vim-galore#temporary-files (modified)
# backup files
set backup
&backupdir = expand('~/.vim/files/backup' .. '//')
set backupext=-vimbackup
set backupskip=
# swap files
&directory = expand('~/.vim/files/swap' .. '//')
# use default value
#set updatecount =100
# undo files
set undofile
&undodir = expand('~/.vim/files/undo/')
# viewdir (:mkview / :loadview)
&viewdir = expand('~/.vim/files/view/')
# viminfo files
&viminfofile = expand('~/.vim/files/viminfo')

# create directory if needed
for t_dir in [
        &backupdir, &directory, &undodir, &viewdir,
        expand('~/.vim/sessions/'),
        ]
    if !isdirectory(t_dir)
        mkdir(t_dir, 'p')
    endif
endfor

# disable some feature
set nobackup
set noundofile

# alt key in terminal {{{2
if !has('gui_running') && is_unix
    # see ":set-termcap"
    for i in 'abcdefghijklmnopqrstuvwxyz1234567890'
        exec printf("set <M-%s>=\<Esc>%s", i, i)
    endfor
    set ttimeoutlen=100
endif

# <S-Space> in terminal {{{2
# additional setup: map <S-Space> to RHS of t_F9 keybinding
# in terminal emulator setting.
#
# t_F9 is <F19>. see ":h 't_F9'"
# (map t_F9 in local vimrc (AFTER souring this file!), since it is hard to
# decide the universe keybinding in different terminal emulators;
# if the terminal emulator supports binding <F19>, then no modification
# required in local vimrc)
#exec "set t_F9=\<Esc>0"
map <F19> <S-Space>
map! <F19> <S-Space>
tmap <F19> <S-Space>

# set env for embedded terminal. {{{2
if !exists('$FZF_DEFAULT_OPTS')
    $FZF_DEFAULT_OPTS = '--cycle --no-sort --no-mouse --color=16'
endif

# disable mouse support by default. make terminal happier. {{{2
if !has('gui_running')
    set mouse=
endif

# IME {{{2
if is_win32
    # when im is on in insert mode, esc to normal mode with im off.
    set iminsert=2
endif

# term & gui (but not colorscheme) {{{2
# TODO g:terminal_ansi_colors works even if (no gui && no tgc). is this a bug?
# NOTE: no `set bg`; seems that terminal theme (dark / light) can be detected.
if has('gui_running')
    # go-!: uniform shell interface, like :!, :sh.
    set guioptions=!
    set lines=30
    set columns=120
else
    if is_win32
        # Try to set termguicolors; if success, &t_Co will be changed to 256,
        # then we can use better looking colorscheme.
        # At least works in windows 10 (1809+?).
        #
        # setting it causes panic in console vim from headless wine.
        # so set it in $MYVIMRC instead.
        #silent! set tgc
        if $CONEMUANSI ==? 'ON'
            # https://conemu.github.io/en/VimXterm.html
            set term=xterm
            set t_Co=256
            &t_AB = "\e[48;5;%dm"
            &t_AF = "\e[38;5;%dm"
        endif
    else
        if $TERM->tolower() == 'linux'
            # linux tty
        else
            # 256color or tgc
            if $TERM !~ 'xterm'
                # make tgc work; :help xterm-true-color
                &t_8f = "\<Esc>[38:2:%lu:%lu:%lum"
                &t_8b = "\<Esc>[48:2:%lu:%lu:%lum"
            endif
            silent! set tgc
        endif

        if &term == 'xterm-kitty'
            # in kitty faq.
            &t_ut = ''
        endif

        if $TERM->tolower() =~? 'xterm' && is_wsl
            # fix vim start in replace mode; https://superuser.com/a/1525060
            set t_u7=
        endif
    endif
endif
# keymap {{{1
# custom text object {{{2
# all
vnoremap aa :<C-u>normal! ggVG<CR>
onoremap aa :<C-u>normal! ggVG<CR>
# line
vnoremap al :<C-u>normal! 0v$h<CR>
onoremap al :<C-u>normal! 0v$h<CR>
# line, strip space
vnoremap il :<C-u>normal! ^vg_<CR>
onoremap il :<C-u>normal! ^vg_<CR>
# fold
vnoremap az V]zo[zo
onoremap az :<C-u>normal! V]zo[zo<CR>
# fold, without marker. (trailing marker is not un-select. press k if it
# exists.)
vnoremap iz V]zo[zjo
onoremap iz :<C-u>normal! V]zo[zjo<CR>

# mswin: disable v_CTRL-X (which is not compatible with unix) {{{2
# use vim_starting check to avoid unexpected behavior (map and then re-source).
if is_win32 && has('vim_starting') && !empty(maparg('<C-x>', 'v'))
    vunmap <C-x>
endif

# <M-hjkl> {{{2
tnoremap <M-h> <C-w>h
tnoremap <M-j> <C-w>j
tnoremap <M-k> <C-w>k
tnoremap <M-l> <C-w>l

nnoremap <M-h> <C-w>h
nnoremap <M-j> <C-w>j
nnoremap <M-k> <C-w>k
nnoremap <M-l> <C-w>l

inoremap <M-h> <C-o><C-w>h
inoremap <M-j> <C-o><C-w>j
inoremap <M-k> <C-o><C-w>k
inoremap <M-l> <C-o><C-w>l

# <C-tab>; <M-t> {{{2
tnoremap <C-Tab> <C-w>gt
tnoremap <S-C-Tab> <C-w>gT

nnoremap <C-Tab> gt
nnoremap <S-C-Tab> gT

inoremap <C-Tab> <C-o>gt
inoremap <S-C-Tab> <C-o>gT

tnoremap <M-t> <C-w>:tabe<CR>
nnoremap <M-t> :tabe<CR>
inoremap <M-t> <C-o>:tabe<CR>

# <M-1> - <M-9> {{{2
for i in range(1, 8)
    execute printf("tnoremap \<M-%d> \<C-w>%dgt", i, i)
    execute printf("nnoremap \<M-%d> %dgt", i, i)
    execute printf("inoremap \<M-%d> \<C-o>\<C-w>%dgt", i, i)
endfor
execute "tnoremap \<M-9> \<C-w>:tablast<CR>"
execute "nnoremap \<M-9> :tablast<CR>"
execute "inoremap \<M-9> \<C-o>:tablast<CR>"
# preserve <M-0> for DE / wm.

# i_<C-u> {{{2
# from defaults.vim
inoremap <C-U> <C-G>u<C-U>

# <Space>t... for tab operation {{{2
for i in range(1, 9)
    execute printf('nnoremap <Space>t%s %sgt', i, i)
endfor
nnoremap <Space>t0 <Cmd>tablast<CR>
# note there is a final <Space>.
nnoremap <Space>tm :tabmove 
nnoremap <Space>tn <Cmd>Sh -wc<CR>
nnoremap <Space>tt <Cmd>call <SID>TabOpenOrClose()<CR>

def TabOpenOrClose()
    if empty(&buftype) && empty(bufname()) && &swapfile && !&modified
        # avoid closing last tab.
        && tabpagenr('$') != 1
        wincmd c
    else
        tabe
    endif
enddef

# n / N {{{2
# always search forward / backward.
# https://vi.stackexchange.com/questions/2365/how-can-i-get-n-to-go-forward-even-if-i-started-searching-with-or#
noremap <expr> n 'Nn'[v:searchforward]
noremap <expr> N 'nN'[v:searchforward]

# v_* / v_#; like `g*` / `g#`, dep: Selection() {{{2
vnoremap <silent> * :<C-u>call feedkeys('/\V' .. substitute(escape(Selection(), '\/'), "\n", '\\n', 'g') .. "\n", 't')<CR>
vnoremap <silent> # :<C-u>call feedkeys('?\V' .. substitute(escape(Selection(), '\/'), "\n", '\\n', 'g') .. "\n", 't')<CR>

# <c-n> / <c-p> to switch buffer. {{{2
nnoremap <C-n> <Cmd>call <SID>SwitchBuffer(v:true)<CR>
nnoremap <C-p> <Cmd>call <SID>SwitchBuffer(v:false)<CR>
def SwitchBuffer(reverse: bool = false)
    var current: number = bufnr()

    const single_window: bool = tabpagebuflist()->len() == 1
    if !single_window
        tabe
    endif

    const term_list = term_list()
    const all_bufs = getbufinfo()
                ->filter((_, i) => !empty(i.name) && !empty(i.listed)
    && index(term_list, i.bufnr) < 0)
                ->mapnew((_, i) => i.bufnr)

    if empty(all_bufs)
        # avoid divide zero
        return
    endif

    var idx = index(all_bufs, current)
    if idx < 0 && reverse
        idx = 0
    endif
    if single_window
        idx += (reverse ? 1 : -1)
    endif
    idx = idx % len(all_bufs)

    execute ':' string(all_bufs[idx]) 'b'
enddef

# gF / v_gF {{{2
# (handle column nr; v_gF handle line / column nr)
# using plugin/jump.vim.
nmap gF <Plug>(jump_to_file)
vmap gF <Plug>(jump_to_file)

# terminal escape; {{{2
# used to use <C-Space>, but it may be occupied by DE / OS. {{{
# I don't use <C-t> key in terminal, so it's ok to map it. }}}
tnoremap <C-t> <C-\><C-n>

# <Space>l {{{2
nnoremap <silent> <Space>l :noh<CR>

# <Space>sl / <Space>ss; mksession. {{{2
nnoremap <Space>sl :so ~/.vim/sessions/
nnoremap <expr> <Space>ss
            \ $':wall \| mksession{empty(v:this_session) ? "" : "!"}'
            \ .. $' {v:this_session ?? "~/.vim/sessions/"}'

# <Space>y / <Space>p; clipboard {{{2
# use pbcopy / pbpaste in $PATH as clipboard; wayland / x11 / tmux ...
# detection is defined there. (~/bin/{pbcopy,pbpaste})
nnoremap <Space>y <Cmd>call <SID>ClipboardCopy("")<CR>
nnoremap <Space>p <Cmd>call <SID>ClipboardPaste("")<CR>

def ClipboardCopy(cmd_: string)
    var cmd = cmd_
    if empty(cmd)
        if has('clipboard') && is_win32
            # NOTE: unix: X11 clipboard content will disapper when program exits.
            # but kde (plasma) has clipboard manager, which make it work
            # consistently.
            # 20221029_133619 wrap stmt with 'execute', since it complains
            # that + register is not available. I guess this is introduced in
            # recent commit.
            execute '@+ = @"'
            return
        elseif executable('pbcopy')
            cmd = 'pbcopy'
        else
            throw 'clipboard not found!'
        endif
        system(cmd, @")
    else
        system(cmd, @")
    endif
enddef

def ClipboardPaste(cmd_: string)
    var cmd = cmd_
    if empty(cmd)
        if has('clipboard') && is_win32
            execute '@" = @+'
            return
        elseif executable('pbpaste')
            cmd = 'pbpaste'
        else
            throw 'clipboard not found!'
        endif
        @" = system(cmd)
    else
        @" = system(cmd)
    endif
enddef

# <Space><CR>; execute current line (or select lines), comment removed {{{2
nnoremap <Space><CR> <Cmd>call <SID>ExecuteLines('n')<CR>
vnoremap <Space><CR> :<C-u>call <SID>ExecuteLines('v')<CR>

def ExecuteLines(mode: string)
    var lines: list<string>
    if mode == 'n'
        lines = [getline('.')]
    elseif mode == 'v'
        lines = getline("'<", "'>")
    endif
    var result_l = []
    for i in lines
        result_l = add(result_l, substitute(i, '\v^\s*(//|#|"|--|;)+', '', ''))
    endfor
    var result: string = join(result_l, "\n")
    echom result
    echo 'execute? y/N '
    if nr2char(getchar())->tolower() == 'y'
        redraws
        try
            execute result
        finally
        endtry
    else
        redraws | echon 'cancelled.'
    endif
enddef

# <Space>n; switch number / relativenumber {{{2
nnoremap <silent> <Space>n <Cmd>call <SID>Switch_nu_rnu()<CR>

def Switch_nu_rnu()
    # no [0, 1]
    const presents = [[1, 1], [1, 0], [0, 0], [1, 1]]
                ->mapnew((_, i) => [i[0] == 1, i[1] == 1])
    const idx = index(presents, [&l:nu, &l:rnu])
    [&l:nu, &l:rnu] = presents[idx + 1]
enddef

# <Space>m; switch mouse {{{2
nnoremap <silent> <Space>m <Cmd>call <SID>Switch_mouse()<CR>

def Switch_mouse()
    if &mouse == 'a'
        set mouse=
    else
        set mouse=a
    endif
enddef

# <Space>q; switch quickfix window (open / focus or close) {{{2
nnoremap <silent> <Space>q <Cmd>call <SID>SwitchQuickfixWindow()<CR>

def SwitchQuickfixWindow()
    if &ft == 'qf'
        cclose
    else
        execute 'bot' 'copen' &cwh
    endif
enddef

# <Space>v; shortcut for reader mode. (view code / text easily.) {{{2
# TODO map more key (one hand); provide help page (double ? to enter search mode).
nnoremap <Space>v <Cmd>call <SID>SwitchReaderMode()<CR>
var reader_mode = exists('reader_mode') ? reader_mode :
{on: false, winid: -1, timeoutlen: 0}

def SwitchReaderMode()
    const mapping =<< trim END
    q <Cmd>call <SID>SwitchReaderMode()<CR>
    <Space> <C-f>
    <S-Space> <C-b>
    f <C-f>
    b <C-b>
    d <C-d>
    u <C-u>
    e <C-e>
    y <C-y>
    x <C-w>c
    1 1gt
    2 2gt
    3 3gt
    4 4gt
    5 5gt
    6 6gt
    7 7gt
    8 8gt
    9 <Cmd>tablast<CR>
    END
    if reader_mode.on
        mapping->mapnew((_, i) => {
            execute 'nunmap' i->split(' ')[0]
        })
        &timeoutlen = reader_mode.timeoutlen
        reader_mode.on = false
        popup_close(reader_mode.winid)
    else
        mapping->mapnew((_, i) => {
            execute 'nnoremap' i
        })
        reader_mode.winid = popup_create(
        ['reader mode'], {
            line: &lines,
            mapping: false,
            highlight: 'Special',
            tabpage: -1,  # show in all tabs.
        }
        )
        reader_mode.timeoutlen = &timeoutlen
        # set to 0 to make <Space> work (skip mapping immediately).
        &timeoutlen = 0
        reader_mode.on = true
    endif
enddef

# <space>gg; like :vim // %, but with vim-fuzzy {{{2
nnoremap <Space>gg <Cmd>call fuzzy#Main('User.currentBuffer')<CR>
g:fuzzy#config->extend({
currentBuffer: {
    Fn: () => getline(1, '$')->mapnew((idx, i) => ({
    text: string(idx + 1), trailer: i, location: '', search_trailer: '1',
    })),
    Callback: (chosen: string) => {
        execute 'normal ' .. chosen->matchstr('\v^[0-9]+') .. 'G'
    }
    }
})
# autocmd {{{1
augroup vimrc
    Source('./rc/autocmd.vim')
augroup END
# coc.nvim config {{{1
if coc_nvim_available
    Source('./rc/coc-settings.vim')
    Source('./rc/coc-config.vim')
endif
# colorscheme {{{1
# only set colorscheme if not set yet. {{{2
# using `trim(execute('color')) == 'default'` is not valid.
if !exists('g:colors_name')
    if has('gui_running') || &t_Co->str2nr() >= 256
        color base16-dynamic
    else
        if is_win32
            # cmd.exe window
            color pablo
            set nocursorcolumn
        else
            color default
        endif
    endif
endif

# terminal statusline tweak {{{2
augroup vimrc
    # colorscheme may not change at startup.
    au ColorScheme * hi! link StatusLineTermNC StatusLineNC
augroup END
hi! link StatusLineTermNC StatusLineNC

# terminal 16color {{{2
def TerminalAnsiColor()
    if !(has('gui_running') || &tgc)
        return
    endif
    # https://github.com/lxhillwind/base16-dynamic.vim
    if &bg == 'dark'
        g:terminal_ansi_colors = ["#263238", "#F07178", "#C3E88D", "#FFCB6B", "#82AAFF", "#C792EA", "#89DDFF", "#EEFFFF", "#546E7A", "#F07178", "#C3E88D", "#FFCB6B", "#82AAFF", "#C792EA", "#89DDFF", "#FFFFFF"]
    else
        g:terminal_ansi_colors = ["#fafafa", "#ca1243", "#50a14f", "#c18401", "#4078f2", "#a626a4", "#0184bc", "#383a42", "#a0a1a7", "#ca1243", "#50a14f", "#c18401", "#4078f2", "#a626a4", "#0184bc", "#090a0b"]
    endif
enddef

augroup vimrc
    au ColorScheme * TerminalAnsiColor()
augroup END
TerminalAnsiColor()
# TODO {{{1
# - toc / content: 'gO' in neovim; (help / markdown, etc.)
# - user completion; 'compl-function'. (tmux buffer, web browser, etc.)
# - vim-fuzzy: page up / page down?
# - search files (globpath(), executable() / exepath() without absolute path,
#   :packadd, :colorscheme) in win32 (wsl) is slow; try to avoid calling them
#   in vimrc.
# - in conemu / xterm ansi escape sequence: popup window is messy.
defc  # show error in this file early. {{{1 }}}1
# vim:fdm=marker:tw=78:sw=4
