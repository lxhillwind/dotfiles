if !has('vim9script') | throw 'vim9script feature not detected!' | endif
vim9script noclear
# internal helper function. {{{1
# expand() should NOT be used to expand arbitrary file (like containing
# "[b-a]" in filename).
def ExpandHead(s: string): string
    if match(s, '\v^[%#<]') == 0
        return expand(s)
    elseif match(s, '\v^\~') == 0
        return expand('~') .. s[1 : ]
    elseif match(s, '\v^\$\ze[a-zA-Z_]') == 0
        const idx = match(s, '\v([^a-zA-Z_]|$)', 1)
        return expand(s[: idx - 1]) .. s[idx : ]
    endif
    return s
enddef

def g:ExpandHead(s: string): string
    return ExpandHead(s)
enddef

def TrSlash(s: string): string
    if has('win32')
        return substitute(s, '\', '/', 'g')
    else
        return s
    endif
enddef

# Source() function is like ":source arg", except that arg is append to
# vimrc's directory.
def Source(file: string)
    execute 'source' fnameescape(vimrc_dir .. '/' .. file)
enddef
const vimrc_dir = expand('<sfile>')->fnamemodify(':h')

# common definition {{{1
const is_unix = has('unix')
const is_win32 = has('win32')
const has_gui = has('gui_running') || has('mac')
|| (has('linux') && (!empty($DISPLAY) || !(empty($WAYLAND_DISPLAY))))
const is_linux = has('linux')
const is_mac = has('mac')
const is_wsl = executable('/mnt/c/Windows/notepad.exe')

g:fuzzy#config = exists('g:fuzzy#config') ? g:fuzzy#config : {}
augroup vimrc
    au!
augroup END

# vimrc detection. {{{1
# Error if reading system-vimrc. {{{
# Some distribution's system-vimrc (like openSUSE) does sth,
# like set mapping, add autocmd.
# Some of these settings are good, but we want to keep these setting in vimrc
# (so it works for other distribution).
# To avoid duplicate setting, we just disable loading system-vimrc.
#
# Suggestion: put `exec /usr/bin/vim -Nu ~/vimfiles/vimrc "$@"` in ~/bin/vim,
# and add ~/bin in $PATH (before /usr/bin), so ~/bin/vim wins.
#
# In some environment (like git-for-windows), it is hard to put custom vim in
# $PATH.
# set vim variable g:vimrc_allow_system or env VIMRC_ALLOW_SYSTEM to 1 to skip check.
#
# Inspection of some distros' system vimrc:
#   git-for-windows:
#     - add autocmd to recover jump; safe to duplicate.
#   openSUSE:
#     - autocmd to recover jump (it's ok);
#     - some key mapping to cause <Ctrl-[> delay, this is not acceptable!
# }}}
const first_vimrc = execute('scr')->split("\n")->get(0)
            ->substitute('\v^.{-}:\s*', '', '')
            ->ExpandHead()
            ->TrSlash()

if has('vim_starting') && exists('$MYVIMRC') && first_vimrc != TrSlash($MYVIMRC)
    if !(
        !empty(get(g:, 'vimrc_allow_system'))
        || !empty($VIMRC_ALLOW_SYSTEM)
        )
        throw 'system-vimrc is read. skip loading vimrc!'
    endif
endif

if !exists('$MYVIMRC')
    # If we use `vim -u ...`, $MYVIMRC will not be set.
    # make ":e $MYVIMRC" work.
    $MYVIMRC = first_vimrc
endif

# config compatible with vim tiny version. {{{1
Source('./rc/tiny.vim')
# option {{{1
# &rtp / &pp {{{2
set rtp=~/vimfiles,$VIMRUNTIME,~/vimfiles/after
set pp=~/vimfiles,$VIMRUNTIME

# add ~/bin to $PATH {{{2
# Even when set ~/bin in $PATH via ~/.config/zshrc, it may not be added when
# invoking gvim from desktop session, then ":sh" / ":Sh" / ":term" may not
# work for command defined in ~/bin.
# So add it to $PATH in vim explicitly.
const env_path_sep = is_win32 ? ';' : ':'
const home_bin = expand('~/bin')
if index($PATH->split(env_path_sep), home_bin) < 0
    $PATH = home_bin .. env_path_sep .. $PATH
endif

# win32 environment prepare {{{2
if is_win32 && has('vim_starting')
    Source('./rc/win32.vim')
endif

# unnamed... {{{2
# vim-vimserver should be called early.
packadd vim-vimserver

# set leader / localleader to unused key, so plugin is hardly to clash with
# our key.
# Refer: lacygoill's vimrc.
g:mapleader = "\<S-F10>"
g:maplocalleader = "\<S-F11>"

# use <Space> as *true* leader key.
noremap <Space> <Nop>
#nnoremap <Space><Space> :nmap <Char-60>Space<Char-62><CR>
# this looks better: vim-fuzzy mapping (n).
nmap <Space><Space> <Space>fmn
nnoremap <Space>;; :map <buffer><CR>

# shell {{{2
# 'shelltemp' or 'noshelltemp': {{{
# - In win32 gui, 'noshelltemp' makes ":!" and ":[range]w !" work like in unix:
# no external cmd window;
# (if guioptions contain '!', ":!" will not show cmd window anyway.)
#
# but encoding cannot be detected (e.g. in "r !")
#
# - In unix, 'noshelltemp' makes ":[range]w !" not create tempfile;
#
# but if guioptions contain '!', ":r !" would not write content to buffer.
#
# So do not change 'shelltemp' option (default on).
# }}}

if is_unix
    const zsh_path = is_mac ? '/opt/homebrew/bin/zsh' : '/bin/zsh'
    if executable(zsh_path)
        &shell = zsh_path
    endif
endif

# cmdline completion {{{2
# defined here instead of legacy, since it is available only after version 8.x
set wildoptions=pum,fuzzy

# builtin terminal enhancement {{{2
def TerminalPaste()
    echo @"
    if @"[-1 : ] == "\n"
        echohl WarningMsg
        echo '<Newline> at end!'
        echohl NONE
    endif
    echo 'paste in terminal? (cursor may be at wrong place!) [y/N] '
    if tolower(nr2char(getchar())) == 'y'
        feedkeys("i\<C-w>" .. '""', 'n')
        redraws | echon 'pasted.'
    else
        redraws | echon 'cancelled.'
    endif
enddef

# define a function, so it can also be used in popup terminal.
def TerminalSetup()
    if &buftype != 'terminal'
        return
    endif
    setl nonu | setl nornu
    # vim-jump
    nmap <buffer> <CR> <Plug>(jump_to_file)
    vmap <buffer> <CR> <Plug>(jump_to_file)
    # clipboard
    nnoremap <buffer> p :<C-u>call <SID>TerminalPaste()<CR>
    nnoremap <buffer> P :<C-u>call <SID>TerminalPaste()<CR>
    # dirvish
    if exists(':Dirvish') == 2
        nnoremap <buffer> - <Cmd>execute 'Dirvish' fnameescape(getcwd())<CR>
    endif
    # <C-w> as in terminal.
    tnoremap <buffer> <C-w> <C-w>.
enddef

augroup vimrc
    au TerminalWinOpen * TerminalSetup()
augroup END

# statusline {{{2
set ruler
&rulerformat = '%20('
.. '%M'
.. ' <%B>'
.. ' %l:%{charcol(".")}%V'
.. '%='
.. '%P'
.. '%)'

# viminfo {{{2
# &viminfo should be set with ^= (the first match will be used) {{{
# according to source code.
# (in file src/viminfo.c, function find_viminfo_parameter())
#
# if option is already present (like '1000), reset (like :so $MYVIMRC) would
# do nothing.
# }}}
set viminfo^='1000

# set locale {{{2
if is_unix
    # some environment cannot set lang, like in minimal container (fedora).
    silent! lang en_US.UTF-8
else
    # for msys2 / git-for-windows, set $LANG to make CJK display correctly.
    $LANG = 'en_US.UTF-8'
    # when libintl.dll is not available, message translation is disabled.
    # so no need to set "$LANG = 'en'". (see :help win32-gettext)
endif

# foldmethod {{{2
# it's too easy to use vim style folder in various text file.
# just set fdm=marker as default.
if has('vim_starting')
    set fdm=marker
endif

# sessionoptions; better ":mksession" option. {{{2
# do not include options in ssop; {{{
# since it breaks mapping with <ScriptCmd>. (like vim-fuzzy)
# Maybe we can use other way to dump mapping.
# }}}
set ssop=blank,curdir,folds,help,tabpages,winsize,terminal

# various vim dir & file {{{2
# copy from https://github.com/mhinz/vim-galore#temporary-files (modified)
# backup files
set backup
&backupdir = expand('~/.vim/files/backup' .. '//')
set backupext=-vimbackup
set backupskip=
# swap files
&directory = expand('~/.vim/files/swap' .. '//')
# use default value
#set updatecount =100
# undo files
set undofile
&undodir = expand('~/.vim/files/undo/')
# viewdir (:mkview / :loadview)
&viewdir = expand('~/.vim/files/view/')
# viminfo files
&viminfofile = expand('~/.vim/files/viminfo')

# create directory if needed
for t_dir in [
        &backupdir, &directory, &undodir, &viewdir,
        expand('~/.vim/sessions/'),
        ]
    if !isdirectory(t_dir)
        mkdir(t_dir, 'p')
    endif
endfor

# disable some feature
set nobackup
set noundofile

# alt key in terminal {{{2
if !has('gui_running') && is_unix
    # see ":set-termcap"
    for i in 'abcdefghijklmnopqrstuvwxyz1234567890'
        exec printf("set <M-%s>=\<Esc>%s", i, i)
    endfor
    set ttimeoutlen=100
endif

# <S-Space> in terminal {{{2
# additional setup: map <S-Space> to RHS of t_F9 keybinding
# in terminal emulator setting.
#
# t_F9 is <F19>. see ":h 't_F9'"
# (map t_F9 in local vimrc (AFTER souring this file!), since it is hard to
# decide the universe keybinding in different terminal emulators;
# if the terminal emulator supports binding <F19>, then no modification
# required in local vimrc)
#exec "set t_F9=\<Esc>0"
map <F19> <S-Space>
map! <F19> <S-Space>
tmap <F19> <S-Space>

# set env for embedded terminal. {{{2
if !exists('$FZF_DEFAULT_OPTS')
    $FZF_DEFAULT_OPTS = '--cycle --no-sort --no-mouse --color=16'
endif

# disable mouse support by default. make terminal happier. {{{2
if !has('gui_running')
    set mouse=
endif

# IME {{{2
if is_win32
    # when im is on in insert mode, esc to normal mode with im off.
    set iminsert=2
endif

# term & gui (but not colorscheme) {{{2
# TODO g:terminal_ansi_colors works even if (no gui && no tgc). is this a bug?
# NOTE: no `set bg`; seems that terminal theme (dark / light) can be detected.
if has('gui_running')
    # go-!: uniform shell interface, like :!, :sh.
    set guioptions=!
    set lines=30
    set columns=120
else
    if is_win32
        # Try to set termguicolors; if success, &t_Co will be changed to 256,
        # then we can use better looking colorscheme.
        # At least works in windows 10 (1809+?).
        #
        # setting it causes panic in console vim from headless wine.
        # so set it in $MYVIMRC instead.
        #silent! set tgc
        if $CONEMUANSI ==? 'ON'
            # https://conemu.github.io/en/VimXterm.html
            set term=xterm
            set t_Co=256
            &t_AB = "\e[48;5;%dm"
            &t_AF = "\e[38;5;%dm"
        endif
    else
        if $TERM->tolower() == 'linux'
            # linux tty
        else
            # 256color or tgc
            if $TERM !~ 'xterm'
                # make tgc work; :help xterm-true-color
                &t_8f = "\<Esc>[38:2:%lu:%lu:%lum"
                &t_8b = "\<Esc>[48:2:%lu:%lu:%lum"
            endif
            silent! set tgc
        endif

        if &term == 'xterm-kitty'
            # in kitty faq.
            &t_ut = ''
        endif

        if $TERM->tolower() =~? 'xterm' && is_wsl
            # fix vim start in replace mode; https://superuser.com/a/1525060
            set t_u7=
        endif
    endif
endif

# keymap {{{1
# custom text object {{{2
# all
vnoremap aa :<C-u>normal! ggVG<CR>
onoremap aa :<C-u>normal! ggVG<CR>
# line
vnoremap al :<C-u>normal! 0v$h<CR>
onoremap al :<C-u>normal! 0v$h<CR>
# line, strip space
vnoremap il :<C-u>normal! ^vg_<CR>
onoremap il :<C-u>normal! ^vg_<CR>
# fold
vnoremap az V]zo[zo
onoremap az :<C-u>normal! V]zo[zo<CR>
# fold, without marker. (trailing marker is not un-select. press k if it
# exists.)
vnoremap iz V]zo[zjo
onoremap iz :<C-u>normal! V]zo[zjo<CR>

# mswin: disable v_CTRL-X (which is not compatible with unix) {{{2
# use vim_starting check to avoid unexpected behavior (map and then re-source).
if is_win32 && has('vim_starting') && !empty(maparg('<C-x>', 'v'))
    vunmap <C-x>
endif

# <M-hjkl> {{{2
tnoremap <M-h> <C-w>h
tnoremap <M-j> <C-w>j
tnoremap <M-k> <C-w>k
tnoremap <M-l> <C-w>l

nnoremap <M-h> <C-w>h
nnoremap <M-j> <C-w>j
nnoremap <M-k> <C-w>k
nnoremap <M-l> <C-w>l

inoremap <M-h> <C-o><C-w>h
inoremap <M-j> <C-o><C-w>j
inoremap <M-k> <C-o><C-w>k
inoremap <M-l> <C-o><C-w>l

# <C-tab>; <M-t> {{{2
tnoremap <C-Tab> <C-w>gt
tnoremap <S-C-Tab> <C-w>gT

nnoremap <C-Tab> gt
nnoremap <S-C-Tab> gT

inoremap <C-Tab> <C-o>gt
inoremap <S-C-Tab> <C-o>gT

tnoremap <M-t> <C-w>:tabe<CR>
nnoremap <M-t> :tabe<CR>
inoremap <M-t> <C-o>:tabe<CR>

# <M-1> - <M-9> {{{2
for i in range(1, 8)
    execute printf("tnoremap \<M-%d> \<C-w>%dgt", i, i)
    execute printf("nnoremap \<M-%d> %dgt", i, i)
    execute printf("inoremap \<M-%d> \<C-o>\<C-w>%dgt", i, i)
endfor
execute "tnoremap \<M-9> \<C-w>:tablast<CR>"
execute "nnoremap \<M-9> :tablast<CR>"
execute "inoremap \<M-9> \<C-o>:tablast<CR>"
# preserve <M-0> for DE / wm.

# i_<C-u> {{{2
# from defaults.vim
inoremap <C-U> <C-G>u<C-U>

# <Space>t... for tab operation {{{2
for i in range(1, 9)
    execute printf('nnoremap <Space>t%s %sgt', i, i)
endfor
nnoremap <Space>t0 <Cmd>tablast<CR>
# note there is a final <Space>.
nnoremap <Space>tm :tabmove 
nnoremap <Space>tn <Cmd>Sh -wc<CR>
nnoremap <Space>tt <Cmd>call <SID>TabOpenOrClose()<CR>

def TabOpenOrClose()
    if empty(&buftype) && empty(bufname()) && &swapfile && !&modified
        # avoid closing last tab.
        && tabpagenr('$') != 1
        wincmd c
    else
        tabe
    endif
enddef

# n / N {{{2
# always search forward / backward.
# https://vi.stackexchange.com/questions/2365/how-can-i-get-n-to-go-forward-even-if-i-started-searching-with-or#
noremap <expr> n 'Nn'[v:searchforward]
noremap <expr> N 'nN'[v:searchforward]

# v_* / v_#; like `g*` / `g#`, dep: Selection() {{{2
vnoremap <silent> * :<C-u>call feedkeys('/\V' .. substitute(escape(Selection(), '\/'), "\n", '\\n', 'g') .. "\n", 't')<CR>
vnoremap <silent> # :<C-u>call feedkeys('?\V' .. substitute(escape(Selection(), '\/'), "\n", '\\n', 'g') .. "\n", 't')<CR>

# <c-n> / <c-p> to switch buffer. {{{2
nnoremap <C-n> <Cmd>call <SID>SwitchBuffer(v:true)<CR>
nnoremap <C-p> <Cmd>call <SID>SwitchBuffer(v:false)<CR>
def SwitchBuffer(reverse: bool = false)
    var current: number = bufnr()

    const single_window: bool = tabpagebuflist()->len() == 1
    if !single_window
        tabe
    endif

    const term_list = term_list()
    const all_bufs = getbufinfo()
                ->filter((_, i) => !empty(i.name) && !empty(i.listed)
    && index(term_list, i.bufnr) < 0)
                ->mapnew((_, i) => i.bufnr)

    if empty(all_bufs)
        # avoid divide zero
        return
    endif

    var idx = index(all_bufs, current)
    if idx < 0 && reverse
        idx = 0
    endif
    if single_window
        idx += (reverse ? 1 : -1)
    endif
    idx = idx % len(all_bufs)

    execute ':' string(all_bufs[idx]) 'b'
enddef

# gF / v_gF {{{2
# (handle column nr; v_gF handle line / column nr)
# using my plugin vim-jump.
nmap gF <Plug>(jump_to_file)
vmap gF <Plug>(jump_to_file)

# terminal escape; {{{2
# used to use <C-Space>, but it may be occupied by DE / OS. {{{
# I don't use <C-t> key in terminal, so it's ok to map it. }}}
tnoremap <C-t> <C-\><C-n>

# <Space>l {{{2
nnoremap <silent> <Space>l :noh<CR>

# <Space>r; simple tasks: plugin/tasks.vim {{{2
nmap <Space>r <Plug>(tasks-select)
vmap <Space>r <Plug>(tasks-select)

# <Space>c; getcwd {{{2
nnoremap <Space>c <Cmd>call <SID>GotoWhichDir()<CR>

def GotoWhichDir()  # {{{
    const dir_buffer: string = Cd_get_buf_dir()
    var dir_project: string
    try
        dir_project = Cd_get_project_dir()
    catch
    endtry
    const dir_home: string = expand('~')
    const dir_cwd: string = getcwd()

    # echo {{{
    if dir_cwd == dir_home
        echon '*'
    endif
    echohl Directory
    echon '[a] home' | echohl None | echon ' '

    if dir_cwd == dir_project
        echon '*'
    endif
    if empty(dir_project)
        echohl WarningMsg
    else
        echohl Directory
    endif
    echon '[d] project' | echohl None | echon ' '

    if dir_cwd == dir_buffer
        echon '*'
    endif
    echohl Directory
    echon '[f] buffer' | echohl None | echon ' '
    # }}}

    echon dir_cwd .. ' > '
    const ch = getcharstr()
    # avoid press enter to continue msg.
    echo "\n" | redrawstatus

    if ch == ' '
        # use <Space> key as escape (like vim-sneak).
    elseif ch == 'a'
        Cdhome
    elseif ch == 'd'
        if !empty(dir_project)
            Cdproject
        else
            echohl Error
            echon 'project dir not available!'
            echohl None
        endif
    elseif ch == 'f'
        Cdbuffer
    else
        # sneak like behavior.
        feedkeys(ch, 't')
    endif
enddef
# }}}

# <Space>sl / <Space>ss; mksession. {{{2
nnoremap <Space>sl :so ~/.vim/sessions/
nnoremap <expr> <Space>ss
            \ $':wall \| mksession{empty(v:this_session) ? "" : "!"}'
            \ .. $' {v:this_session ?? "~/.vim/sessions/"}'

# <Space>y / <Space>p; clipboard {{{2
# use pbcopy / pbpaste in $PATH as clipboard; wayland / x11 / tmux ...
# detection is defined there. (~/bin/{pbcopy,pbpaste})
nnoremap <Space>y <Cmd>call <SID>ClipboardCopy("")<CR>
nnoremap <Space>p <Cmd>call <SID>ClipboardPaste("")<CR>

def ClipboardCopy(cmd_: string)
    var cmd = cmd_
    if empty(cmd)
        if has('clipboard') && is_win32
            # NOTE: unix: X11 clipboard content will disapper when program exits.
            # but kde (plasma) has clipboard manager, which make it work
            # consistently.
            # 20221029_133619 wrap stmt with 'execute', since it complains
            # that + register is not available. I guess this is introduced in
            # recent commit.
            execute '@+ = @"'
            return
        elseif executable('pbcopy')
            cmd = 'pbcopy'
        else
            throw 'clipboard not found!'
        endif
        system(cmd, @")
    else
        system(cmd, @")
    endif
enddef

def ClipboardPaste(cmd_: string)
    var cmd = cmd_
    if empty(cmd)
        if has('clipboard') && is_win32
            execute '@" = @+'
            return
        elseif executable('pbpaste')
            cmd = 'pbpaste'
        else
            throw 'clipboard not found!'
        endif
        @" = system(cmd)
    else
        @" = system(cmd)
    endif
enddef

# <Space><CR>; execute current line (or select lines), comment removed {{{2
nnoremap <Space><CR> <Cmd>call <SID>ExecuteLines('n')<CR>
vnoremap <Space><CR> :<C-u>call <SID>ExecuteLines('v')<CR>

def ExecuteLines(mode: string)
    var lines: list<string>
    if mode == 'n'
        lines = [getline('.')]
    elseif mode == 'v'
        lines = getline("'<", "'>")
    endif
    var result_l = []
    for i in lines
        result_l = add(result_l, substitute(i, '\v^\s*(//|#|"|--|;)+', '', ''))
    endfor
    var result: string = join(result_l, "\n")
    echom result
    echo 'execute? y/N '
    if nr2char(getchar())->tolower() == 'y'
        redraws
        try
            execute result
        finally
        endtry
    else
        redraws | echon 'cancelled.'
    endif
enddef

# <Space>n; switch number / relativenumber {{{2
nnoremap <silent> <Space>n <Cmd>call <SID>Switch_nu_rnu()<CR>

def Switch_nu_rnu()
    # no [0, 1]
    const presents = [[1, 1], [1, 0], [0, 0], [1, 1]]
                ->mapnew((_, i) => [i[0] == 1, i[1] == 1])
    const idx = index(presents, [&l:nu, &l:rnu])
    [&l:nu, &l:rnu] = presents[idx + 1]
enddef

# <Space>m; switch mouse {{{2
nnoremap <silent> <Space>m <Cmd>call <SID>Switch_mouse()<CR>

def Switch_mouse()
    if &mouse == 'a'
        set mouse=
    else
        set mouse=a
    endif
enddef

# <Space>q; switch quickfix window (open / focus or close) {{{2
nnoremap <silent> <Space>q <Cmd>call <SID>SwitchQuickfixWindow()<CR>

def SwitchQuickfixWindow()
    if &ft == 'qf'
        cclose
    else
        execute 'bot' 'copen' &cwh
    endif
enddef

# <Space>v; shortcut for reader mode. (view code / text easily.) {{{2
# TODO map more key (one hand); provide help page (double ? to enter search mode).
nnoremap <Space>v <Cmd>call <SID>SwitchReaderMode()<CR>
var reader_mode = exists('reader_mode') ? reader_mode :
{on: false, winid: -1, timeoutlen: 0}

def SwitchReaderMode()
    const mapping =<< trim END
    q <Cmd>call <SID>SwitchReaderMode()<CR>
    <Space> <C-f>
    <S-Space> <C-b>
    f <C-f>
    b <C-b>
    d <C-d>
    u <C-u>
    e <C-e>
    y <C-y>
    x <C-w>c
    1 1gt
    2 2gt
    3 3gt
    4 4gt
    5 5gt
    6 6gt
    7 7gt
    8 8gt
    9 <Cmd>tablast<CR>
    END
    if reader_mode.on
        mapping->mapnew((_, i) => {
            execute 'nunmap' i->split(' ')[0]
        })
        &timeoutlen = reader_mode.timeoutlen
        reader_mode.on = false
        popup_close(reader_mode.winid)
    else
        mapping->mapnew((_, i) => {
            execute 'nnoremap' i
        })
        reader_mode.winid = popup_create(
        ['reader mode'], {
            line: &lines,
            mapping: false,
            highlight: 'Special',
            tabpage: -1,  # show in all tabs.
        }
        )
        reader_mode.timeoutlen = &timeoutlen
        # set to 0 to make <Space> work (skip mapping immediately).
        &timeoutlen = 0
        reader_mode.on = true
    endif
enddef

# <Space>bb (bookmark add) / <Space>bo (open) / <Space>be (edit) {{{2
nnoremap <Space>bb <Cmd>call <SID>BookmarkAdd()<CR>
nnoremap <Space>bo <Cmd>call fuzzy#Main('User.bookmark')<CR>
nnoremap <Space>be <Cmd>call <SID>BookmarkEdit()<CR>
command! -nargs=* BookmarkAdd BookmarkAdd(<args>)

const bookmark_file = expand('~/.vim/files/bookmark.txt')

def BookmarkAdd(args: dict<any> = {})
    var current_file = bufname('%')
    if current_file->empty()
        throw 'current buffer name is empty!'
    endif
    current_file = current_file->fnamemodify(':p')
    if args->empty()
        const cmdline = printf(
        'BookmarkAdd {"file": "%s", "line": "%d", "title": ""}',
        current_file->escape('"'), line('.'),
        )
        execute 'SetCmdText' cmdline .. "\<Left>"->repeat(2)
    else
        const file: string = args.file
        const line: number = args.line->str2nr()
        const title: string = args.title
        if BookmarkAllData()
                    ->mapnew((_, i) => i->json_decode())
                    ->filter((_, i) => i.file == file && i.line == line)->len() > 0
            throw 'already bookmarked'
        endif
        [
            {file: file, line: line, title: title}->json_encode()
            ]->writefile(bookmark_file, 'a')
        echo 'bookmark created with title: ' .. title .. '.'
    endif
enddef

def BookmarkAllData(): list<string>
    if filereadable(bookmark_file)
        return bookmark_file->readfile()
    endif
    return []
enddef

def BookmarkOpenFn(): list<dict<string>>
    return BookmarkAllData()
                ->mapnew((_, i) => json_decode(i))
                ->filter((_, i) => i.file->filereadable() || i.file->isdirectory())
                ->mapnew((_, i) => ({
    text: i.file .. ':' .. i.line,
    trailer: i.title,
    location: '',
    search_trailer: '1',
                }))
enddef

def BookmarkOpenExFn(line: string): dict<string>
    const res = line->matchstr('\v.*:[0-9]+\ze\t')->split('.*\zs:')
    return {
        filename: res[0],
        lnum: res[1],
    }
enddef

g:fuzzy#config->extend({
bookmark: {
    Fn: BookmarkOpenFn,
    ExtractInfoFn: BookmarkOpenExFn,
    Callback: (chosen: string) => {
        const res = chosen->matchstr('\v.*:[0-9]+$')->split('.*\zs:')
        execute 'e' fnameescape(res[0])
        const linenr = res->get(1, 0)
        if linenr > 0
            execute $'norm {linenr}G'
        endif
    }
    }
})

def BookmarkEdit()
    execute 'SetCmdText' 'edit' bookmark_file->fnameescape()
enddef

# <space>gg; like :vim // %, but with vim-fuzzy {{{2
nnoremap <Space>gg <Cmd>call fuzzy#Main('User.currentBuffer')<CR>
g:fuzzy#config->extend({
currentBuffer: {
    Fn: () => getline(1, '$')->mapnew((idx, i) => ({
    text: string(idx + 1), trailer: i, location: '', search_trailer: '1',
    })),
    Callback: (chosen: string) => {
        execute 'normal ' .. chosen->matchstr('\v^[0-9]+') .. 'G'
    }
    }
})
# plugin loading {{{1
Source('./rc/pack.vim')  # enable :Pack command
Source('./rc/plugin.vim')
if empty($VIMRC_USING_COC)
    Source('./rc/completion-without-coc.vim')
else
    # must-have extensions:
    # :CocInstall coc-json coc-pairs
    set pp+=~/.vim
    if isdirectory('~/.vim/pack/coc/start/coc.nvim'->expand())
        Source('./rc/coc-settings.vim')
        Source('./rc/coc-config.vim')
    else
        const msg =<< trim END
            coc.nvim is not found in `~/.vim/pack/coc/start/coc.nvim`!

            installation method (from https://github.com/neoclide/coc.nvim/wiki/Install-coc.nvim):

            mkdir -p ~/.vim/pack/coc/start
            cd ~/.vim/pack/coc/start
            git clone --branch release https://github.com/neoclide/coc.nvim.git --depth=1
            vim -c "helptags coc.nvim/doc/ | q"
        END
        echohl ErrorMsg
        echo msg->join("\n")
        echohl NONE
        echoerr 'unable to find coc.nvim'
    endif
endif
# update plugin-commit.vim content with `:Pack` then `g`.
Source('./rc/plugin-commit.vim')
# filetype & autocmd {{{1
# filetype related autocmd should be put after this.
filetype plugin indent on
if !exists('g:syntax_on')
    syntax on
endif

augroup vimrc
    Source('./rc/autocmd.vim')
augroup END
# colorscheme {{{1
# only set colorscheme if not set yet. {{{2
# using `trim(execute('color')) == 'default'` is not valid.
if !exists('g:colors_name')
    if has('gui_running') || &t_Co->str2nr() >= 256
        color base16-dynamic
    else
        if is_win32
            # cmd.exe window
            color pablo
            set nocursorcolumn
        else
            color default
        endif
    endif
endif

# terminal statusline tweak {{{2
augroup vimrc
    # colorscheme may not change at startup.
    au ColorScheme * hi! link StatusLineTermNC StatusLineNC
augroup END
hi! link StatusLineTermNC StatusLineNC

# terminal 16color {{{2
def TerminalAnsiColor()
    if !(has('gui_running') || &tgc)
        return
    endif
    # https://github.com/lxhillwind/base16-dynamic.vim
    if &bg == 'dark'
        g:terminal_ansi_colors = ["#263238", "#F07178", "#C3E88D", "#FFCB6B", "#82AAFF", "#C792EA", "#89DDFF", "#EEFFFF", "#546E7A", "#F07178", "#C3E88D", "#FFCB6B", "#82AAFF", "#C792EA", "#89DDFF", "#FFFFFF"]
    else
        g:terminal_ansi_colors = ["#fafafa", "#ca1243", "#50a14f", "#c18401", "#4078f2", "#a626a4", "#0184bc", "#383a42", "#a0a1a7", "#ca1243", "#50a14f", "#c18401", "#4078f2", "#a626a4", "#0184bc", "#090a0b"]
    endif
enddef

augroup vimrc
    au ColorScheme * TerminalAnsiColor()
augroup END
TerminalAnsiColor()

# Command / Function {{{1
# utils function. internal {{{2
def PopupSize(): dict<number>
    const width = max([&columns - 80, 80])
    const height = max([&lines - 24, 24])
    # NOTE: maxwidth / maxheight is not the initial window size!
    return {
        maxwidth: width, maxheight: height,
        minwidth: width, minheight: height,
    }
enddef

# snippet; :Scratch [filetype] / :ScratchNew [filetype] (with new window) {{{2
command -nargs=? -complete=filetype Scratch Scratch(<q-args>)
command! -nargs=? -complete=filetype ScratchNew SnippetInNewWindow(<q-args>)

def Scratch(ft: string)
    enew | setl buftype=nofile noswapfile bufhidden=hide
    if !empty(ft)
        exe 'setl ft=' .. ft
    endif
enddef

def SnippetInNewWindow(ft: string)
    exe printf('bel :%dnew', &cwh)
    setl buftype=nofile noswapfile
    setl bufhidden=hide
    if !empty(ft)
        exe 'setl ft=' .. ft
    endif
enddef

# run vim command; :KvimRun {vim_command}... {{{2
command! -nargs=+ -complete=command KvimRun ShowOutput(execute(<q-args>))

# vim expr; :KvimExpr {vim_expr}... {{{2
command! -nargs=+ -complete=expression KvimExpr ShowOutput(eval(<q-args>))

def ShowOutput(...data_: list<any>)
    # eval() return type may not be string, so use list<any> here.
    const data = type(data_[0]) == type('') ? data_[0] : string(data_[0])
    ScratchNew
    for line in split(data, "\n")
        append('$', line)
    endfor
    norm gg"_dd
enddef

# insert shebang based on filetype; :KshebangInsert [content after "#!/usr/bin/env "] {{{2
command! -nargs=* -complete=shellcmd KshebangInsert ShebangInsert(<q-args>)

g:vimrc_shebang_lines = {
    'awk': 'awk-f',  # awk: wrapper executing "awk -f" is required.
    'javascript': 'node', 'lua': 'lua',
    'perl': 'perl', 'python': 'python', 'ruby': 'ruby',
    'scheme': 'scheme-run',  # scheme: see ~/bin/scheme-run
    'sh': '/bin/sh', 'zsh': 'zsh',
}

def ShebangInsert(args: string)
    const first_line = getline(1)
    if len(first_line) >= 2 && first_line[0 : 1] == '#!'
        throw 'shebang exists!'
    endif
    var shebang: string
    if !empty(args)
        shebang = args
    elseif has_key(g:vimrc_shebang_lines, &ft)
        shebang = g:vimrc_shebang_lines[&ft]
    else
        throw 'shebang: which interpreter to run?'
    endif
    if match(shebang, '^/') >= 0
        shebang = '#!' .. shebang
    else
        shebang = '#!/usr/bin/env ' .. shebang
    endif
    # insert at first line and leave cursor here (for further modification)
    normal ggO<Esc>
    var ret = setline(1, shebang)
    if ret == 0  # success
        normal $
    else
        throw 'setting shebang error!'
    endif
enddef

# match long line; :KmatchLongLine {number} {{{2
# Refer: https://stackoverflow.com/a/1117367
command! -nargs=1 KmatchLongLine exe ':/\%>' .. <args> .. 'v.\+'

# `J` with custom seperator; <range>:J sep... {{{2
command! -nargs=1 -range J JoinLines(<q-args>, <range>, <line1>, <line2>)
def JoinLines(sep: string, range: number, line1: number, line2: number)
    const result = getline(line1, line2)->join(sep)
    deletebufline('%', line1, line2)
    append(max([line1 - 1, 0]), result)
    normal k
enddef

# edit selected line / column; :Kjump {{{2
command! -nargs=+ Kjump JumpToLineCol(<args>)
def JumpToLineCol(line: number, col: number = 0)
    execute 'normal' line .. 'gg'
    if col > 1
        execute 'normal 0' .. (col - 1) .. 'l'
    endif
enddef

# Selection() {{{2
def g:Selection(): string
    const tmp = @"
    var result = ''
    var success = false
    try
        silent normal gvy
        success = true
    finally
        result = @"
        @" = tmp
        if !success
            throw 'g:Selection() failed!'
        endif
    endtry
    return result
enddef

# :SetCmdText / SetCmdText() {{{2
def g:SetCmdText(text: string)
    feedkeys(':' .. text, 't')
enddef

command! -nargs=+ SetCmdText g:SetCmdText(<q-args>)

# :KqutebrowserEditCmd {{{2
if !empty($QUTE_FIFO)
    command! KqutebrowserEditCmd KqutebrowserEditCmd()

    def KqutebrowserEditCmd()
        setl buftype=nofile noswapfile
        setline(1, $QUTE_COMMANDLINE_TEXT[1 :])
        setline(2, '')
        setline(3, 'hit `<Space>q` to save cmd (first line) and quit')
        # weired bug with `map ... \| q...` in vim9script.
        legacy nnoremap <buffer> <Space>q :call writefile(['set-cmd-text -s :' .. getline(1)], $QUTE_FIFO) \| q<CR>
    enddef
endif

# :Tmux {{{2
if exists("$TMUX")
    command! -nargs=1 -bar Tmux TmuxOpenWindow(<q-args>)

    def TmuxOpenWindow(args_: string)
        var args: string = args_
        const options = {'c': 'neww', 's': 'splitw -v', 'v': 'splitw -h'}
        var ch = match(args, '\s')
        var option: string
        if ch == -1
            [option, args] = [args, '']
        else
            [option, args] = [args[: ch], args[ch :]]
        endif
        option = get(options, trim(option))
        if empty(option)
            throw 'unknown option: ' .. args .. '; valid: ' .. join(keys(options), ' / ')
        endif
        call system("tmux " .. option .. " -c " .. shellescape(getcwd()) .. args)
    enddef
endif

# Cd <path> / :Cdalternate / :Cdhome / :Cdbuffer / :Cdproject [:]cmd... {{{2
command! -nargs=1 -complete=dir Cd Cd('', <q-args>)
command! -nargs=* -complete=command Cdalternate Cd('alternate', <q-args>)
command! -nargs=* -complete=command Cdhome Cd('home', <q-args>)
command! -nargs=* -complete=command Cdbuffer Cd('buffer', <q-args>)
command! -nargs=* -complete=command Cdproject Cd('project', <q-args>)

def Cd(flag: string, args: string)
    var cmd = args
    var path: string
    if flag == 'alternate'
        path = fnamemodify(bufname('#'), '%:p:h')
    elseif flag == 'home'
        path = expand('~')
    elseif flag == 'project'
        path = Cd_get_project_dir()
        if empty(path)
            throw 'project dir not found!'
        endif
    elseif flag == 'buffer'
        path = Cd_get_buf_dir()
    else
        if args =~ '^:'
            throw 'path argument is required!'
        endif
        # Cd: split argument as path & cmd
        path = substitute(args, '\v^(.{}) :.+$', '\1', '')
        cmd = args[len(path) + 1 :]
    endif

    if !empty(cmd)
        var old_cwd = getcwd()
        var buf = bufnr('')
        try
            # use buffer variable to store cwd if `exe` switch to new window
            b:vimrc_old_cwd = old_cwd
            silent exe 'lcd' fnameescape(path)
            exe cmd
        finally
            if buf == bufnr('')
                if exists('b:vimrc_old_cwd')
                    unlet b:vimrc_old_cwd
                endif
                silent exe 'lcd' fnameescape(old_cwd)
            endif
        endtry
    else
        exe 'lcd' fnameescape(path)
        if &buftype == 'terminal'
            term_sendkeys(bufnr(''), 'cd ' .. shellescape(path))
            if mode() == 'n'
                feedkeys('i', 't')
            endif
        endif
    endif
enddef

augroup vimrc
    au BufEnter * {
        # reset cd
        if exists('b:vimrc_old_cwd')
            try
                silent exe 'lcd' fnameescape(b:vimrc_old_cwd)
            finally
                unlet b:vimrc_old_cwd
            endtry
        endif
    }
augroup END

def Cd_get_buf_dir(): string
    var path = expand('%:p:h')
    path = path->substitute('\v^(file://)', '', '')
    if empty(path) || &buftype == 'terminal'
        path = getcwd()
    endif
    return path
enddef

def Cd_get_project_dir(): string
    var path = Cd_get_buf_dir()
    var parent: string
    while 1
        if is_win32 && (path == '//' || path == '\\')
            # UNC; isdirectory('///.git') is extremely slow, so stop early.
            return ''
        endif
        if isdirectory(path .. '/.git')
            return path
        endif
        if filereadable(path .. '/.git')
            # git submodule
            return path
        endif
        parent = fnamemodify(path, ':h')
        if path == parent
            return ''
        endif
        path = parent
    endwhile
    # unrechable
    return path
enddef

# terminal-api related user function {{{2
# sync terminal path to buffer path.
# TODO follow cd even when terminal buffer not in focus (with event?).
def g:Tapi_cd(nr: number, arg: list<string>)
    if bufnr() == nr
        var p = arg[0]
        if is_win32 && match(p, '^/') >= 0
            # why not using shellescape() here?
            p = execute(printf("Sh cygpath -w '%s'", substitute(p, "'", "'\\\\''", 'g')))
        endif
        silent execute 'lcd' fnameescape(p)
    endif
enddef

# :Jobrun / :Jobqfrun / :Jobstop / :Joblist / :Jobclear {{{2
command! -range=0 -nargs=+ Jobrun
| JobRun(<q-args>, {range: <range>, line1: <line1>, line2: <line2>, qf: false})
command! -range=0 -nargs=+ Jobqfrun
| JobRun(<q-args>, {range: <range>, line1: <line1>, line2: <line2>, qf: true})
command! -nargs=* -bang -complete=custom,JobStopComp Jobstop
| JobStop(<q-args>, <bang>0 ? 'kill' : 'term')
command! Joblist call JobList()
command! -count Jobclear call JobClear(<count>)

var job_dict = exists('job_dict') ? job_dict : {}

def JobOutCb(ctx: dict<any>, _: channel, msg: string)
    const buf = ctx.bufnr
    setqflist([], 'a', {nr: buf, lines: [msg]})
enddef

def JobExitCb(ctx: dict<any>, job: job, ret: number)
    const buf = ctx.bufnr
    var data = []
    add(data, '')
    add(data, '===========================')
    add(data, 'command finished with code ' .. ret)
    if ctx.qf
        setqflist([], 'a', {nr: buf, lines: data})
    else
        appendbufline(buf, '$', data)
    endif
enddef

def JobRun(cmd_a: string, opt: dict<any>)
    if exists(':Sh') != 2
        throw 'depends on vim-sh plugin!'
    endif
    if exists(':ScratchNew') != 2
        throw 'depends on `:ScratchNew`!'
    endif
    var cmd: string = cmd_a
    var flag: string = '-n'
    if match(cmd, '^-') >= 0
        var tmp = matchlist(cmd, '\v^(-\S+)\s+(.*)$')
        cmd = tmp[2]
        flag = tmp[1] .. 'n'
    endif
    var cmd_short = cmd
    if opt.range != 0
        cmd = printf(':%s,%sSh %s %s', opt.line1, opt.line2, flag, cmd)
    else
        cmd = printf('Sh %s %s', flag, cmd)
    endif
    var job_d = json_decode(execute(cmd))

    # in case running with ":Cd... [path]"
    extend(job_d.opt, {cwd: getcwd()})

    var bufnr: number
    if opt.qf
        var current_max = getqflist({nr: '$'}).nr
        bufnr = current_max + 1
        setqflist([], ' ',
        {
                title: '(:Joblist to check state) ' .. cmd_short, nr: bufnr,
        })
        extend(job_d.opt, {
            out_cb: function(JobOutCb, [{bufnr: bufnr}]),
            err_cb: function(JobOutCb, [{bufnr: bufnr}]),
        })
    else
        ScratchNew
        bufnr = bufnr()
        wincmd p
        extend(job_d.opt, {
            out_io: 'buffer', err_io: 'buffer',
            out_buf: bufnr, err_buf: bufnr,
        })
    endif
    extend(job_d.opt, {
        exit_cb: function(JobExitCb, [{bufnr: bufnr, qf: opt.qf}]),
    })

    extend(job_dict, {
        [bufnr]: {
            job: job_start(job_d.cmd, job_d.opt),
            cmd: cmd_short,
        }
        })
enddef

def JobStop(id_a: string, sig: string)
    var id = empty(id_a) ? bufnr() : str2nr(matchstr(id_a, '\v^\d+'))
    if has_key(job_dict, id)
        job_stop(job_dict[id].job, sig)
    else
        throw 'job not found: buffer id ' .. id
    endif
enddef

def JobStopComp(...arg: list<any>): string
    var result = []
    for [k, v] in items(job_dict)
        if v.job->job_status() == 'run'
            add(result, printf('%s: %s', k, v.cmd))
        endif
    endfor
    return join(result, "\n")
enddef

def JobList()
    for [k, v] in items(job_dict)
        echo printf("%s:\t%s\t%s", k, v.job, v.cmd)
    endfor
enddef

def JobClear(num: number)
    for item in num > 0 ? [num] : keys(job_dict)
        var job = get(job_dict, item)
        if !empty(job)
            if job.job->job_info().status != 'run'
                remove(job_dict, item)
            endif
        endif
    endfor
enddef

# :ChdirTerminal [path]; default path: selection / <cfile>; expand() is applied; use existing terminal if possible; bang: using Sh -w (default: Sh -t) {{{2
# depends on g:Selection().
command! -bang -nargs=* -range=0 ChdirTerminal ChdirTerminal(<bang>false, <range>, <q-args>)

def ChdirTerminal(bang: bool, range: number, path_a: string)
    var path = path_a ?? ( range > 0 ? g:Selection() : expand('<cfile>') )
    if match(path, '\v^[~$<%]') >= 0
        path = ExpandHead(path)
    endif
    path = fnamemodify(path, ':p')
    if filereadable(path)
        path = fnamemodify(path, ':h')
    endif
    if !isdirectory(path)
        throw 'is not directory or not readable: ' .. path
    endif

    const bufs: list<number> = tabpagebuflist()
    if !bang
        for i in term_list()->filter(
            (_, x) => x->term_getstatus() == 'running'
            )
            const idx: number = index(bufs, i)
            if idx >= 0
                echo printf('chdir in window [%d]? [y/N] ', idx + 1)
                if nr2char(getchar())->tolower() == 'y'
                    execute ':' .. (idx + 1) 'wincmd w'
                    call feedkeys(printf('%scd %s', mode() == 'n' ? 'i' : '', shellescape(path)), 't')
                else
                    redrawstatus | echon 'cancelled.'
                endif
                return
            endif
        endfor
    endif
    const cmd = bang ? 'Sh -w' : 'Sh -t'
    execute 'Cd' path ':' .. cmd
enddef

# :vim-fuzzy config {{{2
# ProjectListCmd() {{{3
# NOTE: this variable is directly put after `find` command,
# using shell syntax. QUOTE IT IF NECESSARY!
g:project_dirs = get(g:, 'project_dirs', '~/repos/ ~/vimfiles/')

# accept list<string>; every item is put after -name (or -path, if / included)
g:project_blacklist = get(g:, 'project_blacklist', ['venv', 'node_modules'])

def ProjectListCmd(): string
    if empty(g:project_dirs)
        throw '`g:project_dirs` is not set or empty!'
    endif
    if type(g:project_blacklist) != type([])
        throw '`g:project_blacklist` should be list<string>!'
    endif

    var blacklist = ''
    for i in g:project_blacklist
        if match(i, is_win32 ? '\v[/\\]' : '/') >= 0
            blacklist ..= printf('-path %s -prune -o ', shellescape(i))
        else
            blacklist ..= printf('-name %s -prune -o ', shellescape(i))
        endif
    endfor
    # https://github.com/lxhillwind/utils/tree/main/find-repo
    var find_repo_bin = exepath('find-repo' .. (is_win32 ? '.exe' : ''))
    if !find_repo_bin->empty()
        return printf('%s %s', shellescape(find_repo_bin), g:project_dirs)
    endif
    return printf(
    "find %s %s -name .git -prune -print0 2>/dev/null"
    .. " | { if [ -x /usr/bin/cygpath ]; then xargs -r -0 cygpath -w; else xargs -r -0 -n 1; fi; }"
    .. " | sed -E 's#[\\/].git$##'",
    g:project_dirs, blacklist,
    )
enddef

# TabWinLines() {{{3
def TabWinLines(): list<string>
    var buf_list = []  # preserve order
    var key: string
    for i in range(tabpagenr('$'))
        var j = 0
        for buf in tabpagebuflist(i + 1)
            key = printf('%d %d', i + 1, j + 1)
            buf_list->add(key .. ' ' .. bufname(buf))
            j = j + 1
        endfor
    endfor
    return buf_list
enddef

# config {{{3
g:fuzzy#config->extend({
buffer: {
    excmd: 'ls',
    Callback: (chosen: string) => {
        const bufnr = chosen->matchstr('\v^\s*\zs(\d+)\ze')
        execute ':' .. bufnr .. 'b'
    }
    },
color: {
    LinesFn: () => globpath(&rtp, "colors/*.vim", 0, 1)
                ->mapnew((_, i) => i->split('[\/.]')->get(-2)),
    Callback: (chosen: string) => {
        execute 'color' fnameescape(chosen)
    }
    },
project_dir: {
    shell: ProjectListCmd(),
    ExtractInfoFn: (line) => ({filename: line->split('\t')[0]}),
    Callback: (chosen: string) => {
        execute 'lcd' fnameescape(chosen)
        if exists(':Dirvish') == 2
            execute 'Dirvish' fnameescape(chosen)
        endif
    }
    },
tabwin: {
    LinesFn: TabWinLines,
    Callback: (chosen: string) => {
        const res = chosen->trim()->split(' ')
        const [tab, win] = [res[0], res[1]]
        execute printf(':%stabn', tab)
        execute printf(':%swincmd w', win)
    }
    },
})

# (keymap) popup to select from sources. {{{3
nnoremap <Space>a <Cmd>call <SID>SelectFromSources()<CR>

def SelectFromSources()
    # TODO highlight
    const selection = [
        # [key, g:fuzzy#config]
        ['c', 'color'],
        ['e', 'project_dir'],
        ['b', 'buffer'],
        ['t', 'tabwin'],
        ]
    # some sources may be missing, so check it.
                ->filter((_, i) => !empty(g:fuzzy#config->get(i->get(1))))

    # Is is possible to use ordered dict, so we migrate selection /
    # selection_dict?
    var selection_dict = {}
    var lists = []
    for [k, v] in selection
        add(lists, printf('[%s] %s', k, v))
        selection_dict[k] = v
    endfor
    popup_create(lists, {
        pos: 'center',
        title: 'Select... (any other key to quit)',
        minwidth: min([40, &columns / 2]),
        border: [1, 1, 1, 1],
        mapping: false,
        filter: (winid: number, key: string): bool => {
            const res = get(selection_dict, key)
            if !empty(res)
                g:fuzzy#Main($'User.{res}')
            endif
            # finally.
            popup_close(winid)
            return true
        }
        }
    )
enddef

# sv() helper (in vim embedded terminal) {{{2
def g:Tapi_shell_sv_helper(...arg: list<any>)
    feedkeys("\<C-\>\<C-n>", 'n')
enddef

def g:NoteIdNew(): string # {{{2
    return strftime('%Y%m%d_%H%M%S')
enddef

# :PluginReadme {plugin}; open README file for specified plugin. {{{2
command! -nargs=1 -complete=custom,PluginReadmeComp PluginReadme
| PluginReadme(<q-args>)

def PluginReadme(plugin: string)
    for i in PluginReadmeCache()
        if i->match(plugin) >= 0
            exec 'edit' i->fnameescape()
            return
        endif
    endfor
    echoerr 'plugin README not found: ' .. plugin
enddef

def PluginReadmeComp(..._: list<any>): string
    return PluginReadmeCache()
                ->mapnew((_, i) => i->substitute('\v.*/\ze[^/]+/[^/]+$', '', ''))
                ->join("\n")
enddef

var plugin_readme_cache: list<string> = []
var plugin_readme_set: bool = false
def PluginReadmeCache(): list<string>
    if !plugin_readme_set
        plugin_readme_cache = globpath(&rtp, 'README*', 0, 1)
        plugin_readme_set = true
    endif
    return plugin_readme_cache
enddef
# TODO {{{1
# - toc / content: 'gO' in neovim; (help / markdown, etc.)
# - user completion; 'compl-function'. (tmux buffer, web browser, etc.)
# - vim-fuzzy: page up / page down?
# - search files (globpath(), executable() / exepath() without absolute path,
#   :packadd, :colorscheme) in win32 (wsl) is slow; try to avoid calling them
#   in vimrc.
# - in conemu / xterm ansi escape sequence: popup window is messy.
defc  # show error in this file early. {{{1 }}}1
# vim:fdm=marker:tw=78:sw=4
