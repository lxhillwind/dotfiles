" vim: fdm=marker
" vimrc for +eval.

" about loading order: {{{
"
" disable filetype detection before ":packadd", otherwise ftdetect in packages
" won't be loaded. (call "filetype off" to ensure it is disabled)
"
" "colorscheme XXX" should be called after all ":packadd", since it usally
" depends on "syntax on", which calls "filetype on", if not loaded (or
" filetype-off before).
" }}}

" common definition {{{1
let s:is_unix = has('unix')
let s:is_win32 = has('win32')
let s:has_gui = has('gui_running') || has('mac')
      \ || (has('linux') && (!empty($DISPLAY) || !(empty($WAYLAND_DISPLAY))))

" :echoerr will raise exception (?)
function! s:echoerr(msg)
  echohl ErrorMsg
  echon a:msg
  echohl None
endfunction

" option {{{1
" add this directory to &rtp / &pp {{{2
execute 'set rtp^=' . fnameescape(expand('<sfile>:p:h'))
execute 'set rtp+=' . fnameescape(expand('<sfile>:p:h') . '/after')
if exists('&pp')
  execute 'set pp^=' . fnameescape(expand('<sfile>:p:h'))
endif

" s:helper {{{2
let s:self = expand('<sfile>')
function! s:load_script(file) abort
  exec 'source' fnameescape(fnamemodify(s:self, ':p:h') . '/' . a:file)
endfunction

" }}}2
if has('vim_starting')
  call s:load_script('vimrc.tiny')
endif

if has('win32')
  " setup env before calling vim-vimserver in rc/option.vim
  call s:load_script('rc/win32.vim')
endif

" vim-vimserver should be called early.
call s:load_script('pack/lx/opt/vim-vimserver/plugin/vimserver.vim')

" map early
let mapleader = ' '  " assign before use
let maplocalleader = ' ;'
noremap <Space> <Nop>

" uniform builtin terminal {{{2
augroup vimrc_terminal
  au!
  function! s:terminal_paste()
    echo @"
    if @"[-1:] == "\n"
      echohl WarningMsg
      echo '<Newline> at end!'
      echohl NONE
    endif
    echo 'paste in terminal? (cursor may be at wrong place!) [y/N] '
    if tolower(nr2char(getchar())) == 'y'
      if has('nvim')
        call feedkeys('pi', 'n')
      else
        call feedkeys("i\<C-w>" . '""', 'n')
      endif
      redraws | echon 'pasted.'
    else
      redraws | echon 'cancelled.'
    endif
  endfunction
  function! s:terminal_init()
    " NOTE: keymap defined here (terminal [p]aste).
    if &buftype ==# 'terminal'
      setl nonu | setl nornu
      " vim-jump
      nmap <buffer> <CR> <Plug>(jump_to_file)
      vmap <buffer> <CR> <Plug>(jump_to_file)
      nnoremap <buffer> p :<C-u>call <SID>terminal_paste()<CR>
      nnoremap <buffer> P :<C-u>call <SID>terminal_paste()<CR>
    endif
  endfunction
  if exists('##TerminalOpen')
    au TerminalOpen * call s:terminal_init()
  elseif exists('##TermOpen')
    au TermOpen * call s:terminal_init()
  endif
augroup END

" statusline {{{2
if has('patch-8.2.2854')
  " %{% expr %}
  let &stl = '[%{winnr()},%{mode()}' . '%{% empty(&buftype) ? "%M%R" : "" %}]'
        \ . '%{ empty(&ft) ? "" : " [".&ft."]" }'
        \ . ' %<%F'
        \ . ' %=<%B>'
        \ . ' [%l:' . (exists('*charcol') ? '%{charcol(".")}' : '%cb')
        \ . '%{% &buftype == "terminal" ? "" : "/%L" %}' . ']'
else
  let &stl = '[%{winnr()},%{mode()}%M%R]'
        \ . '%{ empty(&ft) ? "" : " [".&ft."]" }'
        \ . ' %<%F'
        \ . ' %=<%B>'
        \ . ' [%l:' . (exists('*charcol') ? '%{charcol(".")}' : '%cb')
        \ . '/%L]'
endif

" set locale {{{2
if has('unix')
  lang en_US.UTF-8
else
  let $LANG = 'en'
endif

" disable default plugin {{{2
let g:loaded_2html_plugin = 1
let g:loaded_getscriptPlugin = 1
let g:loaded_gzip = 1
let g:loaded_logiPat = 1
let g:loaded_netrwPlugin = 1
let g:loaded_tarPlugin = 1
let g:loaded_vimballPlugin = 1
let g:loaded_zipPlugin = 1

" various vim dir & file {{{2
" copy from https://github.com/mhinz/vim-galore#temporary-files (modified)
" backup files
set backup
let &backupdir = expand('~/.vim/files/backup' . '//')
set backupext=-vimbackup
set backupskip=
" swap files
let &directory = expand('~/.vim/files/swap' . '//')
" use default value
"set updatecount =100
" undo files
set undofile
let &undodir = expand('~/.vim/files/undo/')
" viewdir (:mkview / :loadview)
let &viewdir = expand('~/.vim/files/view/')
" viminfo files
if exists('&viminfofile')
  let &viminfofile = expand('~/.vim/files/viminfo')
endif

" create directory if needed
for s:t_dir in [&backupdir, &directory, &undodir, &viewdir]
  if !isdirectory(s:t_dir)
    call mkdir(s:t_dir, 'p')
  endif
endfor

" disable some feature
set nobackup
set noundofile

" term & gui (but not colorscheme) {{{2
" TODO g:terminal_ansi_colors works even if (no gui && no tgc). is this a bug?
if has('vim_starting')
  if has('gui_running')
    set guioptions=
    set lines=32
    set columns=128
  else
    if has('unix')
      if $TERM ==? 'linux'
        " linux tty
        set bg=dark
      else
        " 256color or tgc
        if exists('&tgc') && $TERM !~ 'xterm'
          " make tgc work; :help xterm-true-color
          let &t_8f = "\<Esc>[38:2:%lu:%lu:%lum"
          let &t_8b = "\<Esc>[48:2:%lu:%lu:%lum"
        endif
        silent! set termguicolors
        if $BAT_THEME =~? 'light'
          set bg=light
        else
          set bg=dark
        endif
      endif

      if $TERM =~? 'xterm' && executable('/mnt/c/Windows/notepad.exe')
        " wsl; fix vim start in replace mode;
        " Refer: https://superuser.com/a/1525060
        set t_u7=
      endif
    else
      " win32 cmd
      set nocursorcolumn
    endif
  endif
endif

" alt key in terminal {{{2
if !has('gui_running') && !has('nvim') && has('unix')
  " see ":set-termcap"
  " for on string is introduced in v8.2.2658; so use list here.
  for s:i in split('abcdefghijklmnopqrstuvwxyz1234567890', '\zs')
    exec printf("set <M-%s>=\<Esc>%s", s:i, s:i)
  endfor
  set ttimeoutlen=100
endif
" }}}2

" keymap {{{1
" clipboard (see keymap) {{{2
" use pbcopy / pbpaste in $PATH as clipboard; wayland / x11 / tmux ...
" detection is defined there. (~/bin/{pbcopy,pbpaste})

function! s:clipboard_copy(cmd)
  if empty(a:cmd)
    if has('clipboard') && !s:is_unix
      " unix: X11 clipboard content will disapper when program exits.
      let @+ = @"
      return
    endif
    if executable('pbcopy')
      let l:cmd = 'pbcopy'
    else
      call s:echoerr('clipboard not found!') | return
    endif
    call system(l:cmd, @")
  else
    call system(a:cmd, @")
  endif
endfunction

function! s:clipboard_paste(cmd)
  if empty(a:cmd)
    if has('clipboard') && !s:is_unix
      let @" = @+
      return
    endif
    if executable('pbpaste')
      let l:cmd = 'pbpaste'
    else
      call s:echoerr('clipboard not found!') | return
    endif
    let @" = system(l:cmd)
  else
    let @" = system(a:cmd)
  endif
endfunction

" execute current line (or select lines), comment removed (see keymap) {{{2
function! s:execute_lines(mode)
  if a:mode == 'n'
    let lines = [getline('.')]
  elseif a:mode == 'v'
    let t = @"
    silent normal gvy
    let lines = split(@", "\n")
    let @" = t
  endif
  let result = []
  for l:i in lines
    " TODO add more comment (or based on filetype).
    let result = add(result, substitute(l:i, '\v^\s*(//|#|"|--)+', '', ''))
  endfor
  let result = join(result, "\n")
  echom result
  echo 'execute? y/N '
  if nr2char(getchar()) ==? 'y'
    redraws
    try
      execute result
    finally
    endtry
  else
    redraws | echon 'cancelled.'
  endif
endfunction

" gx related (NOTE: key `gx` overwritten) {{{2
nnoremap <silent> gx :call <SID>gx('n')<CR>
vnoremap <silent> gx :<C-u>call <SID>gx('v')<CR>

" TODO fix quote / escape
function! s:gx_open_cmd(s)
  if executable('xdg-open')
    return ['xdg-open', a:s]
  elseif executable('open')
    return ['open', a:s]
  elseif s:is_win32
    " TODO fix open for win32
    return ['cmd', '/c', isdirectory(a:s) ? 'explorer' : 'start', a:s]
  else
    call s:echoerr('do not know how to open') | return
  endif
endfunction

" TODO show error?
function! s:gx_open(...)
  let text = join(getline(1, '$'), "\n")
  if empty(text)
    return
  endif
  if empty(a:0)
    let open_cmd = s:gx_open_cmd(text)
  else
    let open_cmd = [a:1, text]
  endif
  if empty(open_cmd)
    return
  endif
  call job_start(open_cmd, {'stoponexit': ''})
endfunction

function! s:gx_open_gx(...)
  if a:0 == 1
    call s:gx_open(a:1)
  else
    call s:gx_open()
  endif
  let winnr = winnr()
  wincmd p
  execute winnr . 'wincmd c'
endfunction

function! s:gx_vim(...)
  " a:1 -> cmd; a:2 -> text modifier; a: 3 -> post string.
  let text = join(getline(1, '$'), "\n")
  if empty(text)
    return
  endif
  if empty(a:0)
    let cmd = text
  else
    if a:0 >= 2 && !empty(a:2)
      let text = function(a:2)(text)
    endif
    let cmd = a:1 . ' ' . text
    if a:0 >= 3 && !empty(a:3)
      let cmd .= a:3
    endif
  endif
  exe cmd
endfunction

function! s:gx(mode) abort
  if a:mode == 'v'
    let t = @"
    silent normal gvy
    let text = @"
    let @" = t
  else
    let text = expand(get(g:, 'netrw_gx', '<cfile>'))
  endif
  exe printf('bel %dnew', &cwh)
  " a special filetype
  setl ft=gx
  for line in split(text, "\n")
    call append('$', line)
  endfor
  norm gg"_dd
endfunction

" switch number / relativenumber {{{2
function! s:switch_nu_rnu() abort
  " patch-7.3.1115: set one of nu / rnu will affect another.
  if v:version < 704
    " [1, 0] -> [0, 0] -> [0, 1] -> [1, 0]
    if &nu
      setl nonu
    elseif &rnu
      setl nu
    else
      setl rnu
    endif
    return
  endif
  " no [0, 1]
  let presents = [[1, 1], [1, 0], [0, 0], [1, 1]]
  let idx = index(presents, [&l:nu, &l:rnu])
  let [&l:nu, &l:rnu] = presents[idx+1]
endfunction

" keymap {{{2
" terminal <C-Space>
map <Nul> <C-Space>
map! <Nul> <C-Space>
if exists(':tmap') == 2
  tmap <Nul> <C-Space>
endif

tnoremap <M-h> <C-w>h
tnoremap <M-j> <C-w>j
tnoremap <M-k> <C-w>k
tnoremap <M-l> <C-w>l

nnoremap <M-h> <C-w>h
nnoremap <M-j> <C-w>j
nnoremap <M-k> <C-w>k
nnoremap <M-l> <C-w>l

inoremap <M-h> <C-o><C-w>h
inoremap <M-j> <C-o><C-w>j
inoremap <M-k> <C-o><C-w>k
inoremap <M-l> <C-o><C-w>l

tnoremap <C-Tab> <C-w>gt
tnoremap <S-C-Tab> <C-w>gT

nnoremap <C-Tab> gt
nnoremap <S-C-Tab> gT

inoremap <C-Tab> <C-o>gt
inoremap <S-C-Tab> <C-o>gT

tnoremap <M-t> <C-w>:tabe<CR>
nnoremap <M-t> :tabe<CR>
inoremap <M-t> <C-o>:tabe<CR>

for s:i in range(1, 9)
  execute printf("tnoremap \<M-%d> \<C-w>%dgt", s:i, s:i)
  execute printf("nnoremap \<M-%d> %dgt", s:i, s:i)
  execute printf("inoremap \<M-%d> \<C-o>\<C-w>%dgt", s:i, s:i)
endfor

" completion
inoremap <C-Space> <C-x><C-o>

" clear hlsearch
nnoremap <silent> <Leader>l :noh<CR>

" custom text object
vnoremap aa :<C-u>normal! ggVG<CR>
onoremap aa :<C-u>normal! ggVG<CR>
vnoremap al :<C-u>normal! 0v$h<CR>
onoremap al :<C-u>normal! 0v$h<CR>
vnoremap il :<C-u>normal! ^vg_<CR>
onoremap il :<C-u>normal! ^vg_<CR>

" clipboard
nnoremap <Leader>y :call <SID>clipboard_copy("")<CR>
nnoremap <Leader>p :call <SID>clipboard_paste("")<CR>

" filelist buffer; vim-filelist
nmap <Leader>f <Plug>(filelist_show)

" simple tasks: tasks.vim
nmap <Leader>r <Plug>(tasks-select)
vmap <Leader>r <Plug>(tasks-select)

" execute current line
nnoremap <Leader><CR> :call <SID>execute_lines('n')<CR>
vnoremap <Leader><CR> :<C-u>call <SID>execute_lines('v')<CR>

" terminal escape
if exists(':tnoremap')
  tnoremap <C-Space> <C-\><C-n>
  if !has('nvim')
    tnoremap <C-w> <C-w>.
  endif
endif

" switch nu / rnu
nnoremap <silent> <Leader>n :call <SID>switch_nu_rnu()<CR>

" filetype related keymap setting {{{2
augroup vimrc_keymap
  au!

  " viml completion
  au FileType vim inoremap <buffer> <C-Space> <C-x><C-v>

  " markdown checkbox {{{
  function! s:markdown_checkbox()
    hi link CheckboxUnchecked Type
    hi link CheckboxChecked Comment
    syn match CheckboxUnchecked '\v^\s*- \[ \] '
    syn match CheckboxChecked '\v^\s*- \[X\] '
  endfunction

  function! s:markdown_toggle_task_status()
    let lineno = line('.')
    let line = getline(lineno)
    if line =~# '\v^\s*- \[X\] '
      let line = substitute(line, '\v(^\s*- )@<=\[X\] ', '', '')
    elseif line =~# '\v^\s*- \[ \] '
      let line = substitute(line, '\v(^\s*- \[)@<= ', 'X', '')
    elseif line =~# '\v^\s*- '
      let line = substitute(line, '\v(^\s*-)@<= ', ' [ ] ', '')
    endif
    call setline(lineno, line)
  endfunction
  " }}}
  au FileType markdown call s:markdown_checkbox() | nnoremap <buffer>
        \ <LocalLeader>c :call <SID>markdown_toggle_task_status()<CR>

  " simple filelist (vim-filelist)
  function! s:filelist_init()
    nmap <buffer> <LocalLeader><CR> <Plug>(filelist_cd)
    nmap <buffer> <CR> <Plug>(filelist_edit)
  endfunction
  au FileType filelist call <SID>filelist_init()

  " gx
  function! s:gx_init()
    setl buftype=nofile noswapfile
    setl bufhidden=hide
    if executable('qutebrowser')
      nnoremap <buffer> <LocalLeader>s :call <SID>gx_open('qutebrowser')<CR>
    endif
    nnoremap <buffer> gx :call <SID>gx_open_gx()<CR>
    if executable('qutebrowser') && s:has_gui
      nnoremap <buffer> gs :call <SID>gx_open_gx('qutebrowser')<CR>
    endif
    nnoremap <buffer> <LocalLeader>f :call <SID>gx_open()<CR>
    nnoremap <buffer> <LocalLeader>v :call <SID>gx_vim('wincmd p \|')<CR>
  endfunction
  au FileType gx call <SID>gx_init()
augroup END

" finally {{{2
" e.g. <Space><Space>
nnoremap <Leader><Leader> :nmap <Char-60>Leader<Char-62><CR>
" e.g. <Space>;; / \\
execute 'nnoremap <LocalLeader>' .
      \ (len(maplocalleader) > 1 ? matchstr(maplocalleader, '.$') : '<LocalLeader>') .
      \ ' :nmap <Char-60>LocalLeader<Char-62><CR>'

" filetype setting {{{1
augroup vimrc_filetype
  au!
  au BufNewFile,BufRead *.gv setl ft=dot
  au FileType vim setl sw=2
  au FileType yaml setl sw=2 indentkeys-=0#
  au FileType zig setl fp=zig\ fmt\ --stdin
  au FileType markdown setl tw=78

  " quickfix window
  au FileType qf let &l:stl = &g:stl
augroup END

" ":h ft-sh-syntax"
let g:is_posix = 1

" misc {{{1
" some variable used by plugin (can be overwritten in vimrc.local) {{{2
function! s:joinpath(path) abort
  return fnamemodify(s:self, ':h') . '/' . a:path
endfunction

let g:tasks_config_paths = [s:joinpath('config/tasks.ini')]
if filereadable(s:joinpath('config/tasks-local.ini'))
  call add(g:tasks_config_paths, s:joinpath('config/tasks-local.ini'))
endif

" plugin {{{1
" first, enable ":Pack" command.
call s:load_script('rc/pack.vim')

" ensure filetype detection is disabled before calling ":packadd".
filetype off

Pack 'vim-filelist'
Pack 'vim-jump'
Pack 'vim-sh'

" more plugin {{{1
if filereadable(fnamemodify(s:self, ':p:h') . '/' . 'vimrc.local')
  " source local vimrc
  call s:load_script('vimrc.local')
else
  " use default plugin
  call s:load_script('rc/pkgs.vim')
  syntax on
endif

if !exists('g:syntax_on')
  echoerr 'vimrc.local: "syntax on" or "syntax enable" should be called early (after :packadd)!'
endif

" this also enables filetype.
filetype plugin indent on

" colorscheme {{{1
" only set colorscheme if not set yet. {{{2
" using `trim(execute('color')) == 'default'` is not valid.
if !exists('g:colors_name')
  if has('gui_running') || &t_Co >= 256
    color base16-dynamic
  else
    if has('win32')
      " win32 cmd
      color pablo
    else
      " no 256color
      color default
    endif
  endif
endif

" terminal statusline tweak {{{2
augroup vimrc_statuslinetermnc
  au!
  " colorscheme may not change at startup.
  au ColorScheme * hi! link StatusLineTermNC StatusLineNC
augroup END
hi! link StatusLineTermNC StatusLineNC

" terminal 16color {{{2
function! s:vimrc_terminal_ansi_color()
  if !(has('gui_running') || &tgc)
    return
  endif
  " https://github.com/lxhillwind/base16-dynamic.vim
  if &bg == 'dark'
    let g:terminal_ansi_colors = ["#263238","#F07178","#C3E88D","#FFCB6B","#82AAFF","#C792EA","#89DDFF","#EEFFFF","#546E7A","#F07178","#C3E88D","#FFCB6B","#82AAFF","#C792EA","#89DDFF","#FFFFFF"]
  else
    let g:terminal_ansi_colors = ["#fafafa","#ca1243","#50a14f","#c18401","#4078f2","#a626a4","#0184bc","#383a42","#a0a1a7","#ca1243","#50a14f","#c18401","#4078f2","#a626a4","#0184bc","#090a0b"]
  endif

  if has('nvim')
    for l:i in range(0, 15)
      execute printf('let g:terminal_color_%s = g:terminal_ansi_colors[%s]', l:i, l:i)
    endfor
  endif
endfunction

augroup vimrc_terminal_ansi_color
  au!
  au ColorScheme * call s:vimrc_terminal_ansi_color()
augroup END
call s:vimrc_terminal_ansi_color()
