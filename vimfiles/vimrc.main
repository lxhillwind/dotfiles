" vim: fdm=marker
" vimrc for +eval.

if v:version < 800
  echoerr 'vim version too old:' v:version
  finish
endif

" common script var / script func. {{{1
let s:nix_default = fnamemodify(expand('<sfile>'), ':p:h:h')
let s:nix_dir = get(s:, 'nix_dir', s:nix_default)
unlet s:nix_default

" common platform detection
let s:is_unix = has('unix')
let s:is_win32 = has('win32')
let s:has_gui = has('gui_running') || has('mac')
      \ || (has('linux') && (!empty($DISPLAY) || !(empty($WAYLAND_DISPLAY))))

" :echoerr will raise exception (?)
function! s:echoerr(msg)
  echohl ErrorMsg
  echon a:msg
  echohl None
endfunction

" an augroup for unnamed event.
augroup vimrc_unnamed
  au!
augroup END
" }}}1

" option {{{1
" before doing thing {{{2
" sensible
exe 'source' fnameescape(s:nix_dir . '/vimfiles/' . 'vimrc.tiny')

" make plugin work
execute 'set rtp^=' . fnameescape(expand('<sfile>:p:h'))
execute 'set rtp+=' . fnameescape(expand('<sfile>:p:h') . '/after')
if exists('&pp')
  execute 'set pp^=' . fnameescape(expand('<sfile>:p:h'))
endif

" map early
let mapleader = ' '  " assign before use
let maplocalleader = ' ;'
noremap <Space> <Nop>

" vim-vimserver {{{2
if !exists('g:vimserver_ignore')
  let g:vimserver_ignore = 1
endif
runtime pack/lx/opt/vim-vimserver/plugin/vimserver.vim
call vimserver#main()


" +eval version vimrc default {{{2
if has('vim_starting')
  syntax on

  augroup vimrc_terminal
    au!
    function! s:terminal_paste()
      echo @"
      if @"[-1:] == "\n"
        echohl WarningMsg
        echo '<Newline> at end!'
        echohl NONE
      endif
      echo 'paste in terminal? (cursor may be at wrong place!) [y/N] '
      if tolower(nr2char(getchar())) == 'y'
        if has('nvim')
          call feedkeys('p', 'n')
        else
          call feedkeys("i\<C-w>" . '""' . "\<C-\>\<C-n>", 'n')
        endif
        redraws | echon 'pasted.'
      else
        redraws | echon 'cancelled.'
      endif
    endfunction
    function! s:terminal_init()
      " NOTE: keymap defined here (terminal [p]aste).
      if &buftype ==# 'terminal'
        setl nonu | setl nornu
        " vim-jump
        nmap <buffer> <CR> <Plug>(jump_to_file)
        vmap <buffer> <CR> <Plug>(jump_to_file)
        nnoremap <buffer> p :<C-u>call <SID>terminal_paste()<CR>
        nnoremap <buffer> P :<C-u>call <SID>terminal_paste()<CR>
      endif
    endfunction
    if exists('##TerminalOpen')
      au TerminalOpen * call s:terminal_init()
    elseif exists('##TermOpen')
      au TermOpen * call s:terminal_init()
    endif
  augroup END
endif

" statusline
if has('patch-8.2.2854')
  " %{% expr %}
  let &stl = '[%{winnr()},%{mode()}' . '%{% empty(&buftype) ? "%M%R" : "" %}]'
        \ . '%{ empty(&ft) ? "" : " [".&ft."]" }'
        \ . ' %<%F'
        \ . ' %=<%B>'
        \ . ' [%l:' . (exists('*charcol') ? '%{charcol(".")}' : '%cb')
        \ . '%{% &buftype == "terminal" ? "" : "/%L" %}' . ']'
else
  let &stl = '[%{winnr()},%{mode()}%M%R]'
        \ . '%{ empty(&ft) ? "" : " [".&ft."]" }'
        \ . ' %<%F'
        \ . ' %=<%B>'
        \ . ' [%l:' . (exists('*charcol') ? '%{charcol(".")}' : '%cb')
        \ . '/%L]'
endif

" set locale
if has('unix')
  lang en_US.UTF-8
else
  let $LANG = 'en'
endif

" disable default plugin
let g:loaded_2html_plugin = 1
let g:loaded_getscriptPlugin = 1
let g:loaded_gzip = 1
let g:loaded_logiPat = 1
let g:loaded_netrwPlugin = 1
let g:loaded_tarPlugin = 1
let g:loaded_vimballPlugin = 1
let g:loaded_zipPlugin = 1

" various tmpfile {{{2
" copy from https://github.com/mhinz/vim-galore#temporary-files (modified)
" backup files
set backup
let &backupdir = expand('~/.vim/files/backup/')
set backupext=-vimbackup
set backupskip=
" swap files
let &directory = expand('~/.vim/files/swap' . '//')
" use default value
"set updatecount =100
" undo files
set undofile
let &undodir = expand('~/.vim/files/undo/')
" viminfo files
if exists('&viminfofile')
  let &viminfofile = expand('~/.vim/files/viminfo')
endif

" create directory if needed
for s:t_dir in [&backupdir, &directory, &undodir]
  if !isdirectory(s:t_dir)
    call mkdir(s:t_dir, 'p')
  endif
endfor

" disable some feature
set nobackup
set noundofile

" colorscheme, term setting {{{2
if has('vim_starting')
" only set colorscheme on start {{{3
" terminal statusline tweak
hi! link StatusLineTermNC StatusLineNC
augroup vimrc_statuslinetermnc
  au!
  " colorscheme may not change at startup.
  au ColorScheme * hi! link StatusLineTermNC StatusLineNC
augroup END

" terminal 16color
augroup vimrc_terminal_ansi_color
  function! s:vimrc_terminal_ansi_color()
    " https://github.com/lxhillwind/base16-dynamic.vim
    if &bg == 'dark'
      let g:terminal_ansi_colors = ["#263238","#F07178","#C3E88D","#FFCB6B","#82AAFF","#C792EA","#89DDFF","#EEFFFF","#546E7A","#F07178","#C3E88D","#FFCB6B","#82AAFF","#C792EA","#89DDFF","#FFFFFF"]
    else
      let g:terminal_ansi_colors = ["#fafafa","#ca1243","#50a14f","#c18401","#4078f2","#a626a4","#0184bc","#383a42","#a0a1a7","#ca1243","#50a14f","#c18401","#4078f2","#a626a4","#0184bc","#090a0b"]
    endif

    if has('nvim')
      for l:i in range(0, 15)
        execute printf('let g:terminal_color_%s = g:terminal_ansi_colors[%s]', l:i, l:i)
      endfor
    endif
  endfunction

  au!
  au ColorScheme * call s:vimrc_terminal_ansi_color()
augroup END

let s:is_unix = has('unix')
if !s:is_unix && !has('gui_running')  " win32 cmd
  set nocursorcolumn
  color pablo
elseif (s:is_unix && $TERM ==? 'linux')  " linux tty
  set bg=dark
else
  if !has('gui_running') && exists('&tgc') && $TERM !~ 'xterm'
    " make tgc work; :help xterm-true-color
    let &t_8f = "\<Esc>[38:2:%lu:%lu:%lum"
    let &t_8b = "\<Esc>[48:2:%lu:%lu:%lum"
  endif
  silent! set termguicolors
  if $BAT_THEME =~? 'light'
    set bg=light
  else
    set bg=dark
  endif
  try
    color base16-dynamic
  catch
    if has('gui_running') || exists('&tgc')
      color desert
    endif
  endtry
endif

if s:is_unix && $TERM =~? 'xterm' && executable('/mnt/c/Windows/notepad.exe')
  " fix vim start in replace mode;
  " Refer: https://superuser.com/a/1525060
  set t_u7=
endif
" }}}3
endif

" gvimrc {{{2
function! s:gui_init()
  if !has('vim_starting')
    return
  endif
  set guioptions=
  set lines=32
  set columns=128
endfunction

if has('gui_running')
  call s:gui_init()
endif

" }}}
" }}}1

" keymap and related command {{{
" clipboard (see keymap) {{{2
" use pbcopy / pbpaste in $PATH as clipboard; wayland / x11 / tmux ...
" detection is defined there. (~/bin/{pbcopy,pbpaste})

function! s:clipboard_copy(cmd)
  if empty(a:cmd)
    if has('clipboard') && !s:is_unix
      " unix: X11 clipboard content will disapper when program exits.
      let @+ = @"
      return
    endif
    if executable('pbcopy')
      let l:cmd = 'pbcopy'
    else
      call s:echoerr('clipboard not found!') | return
    endif
    call system(l:cmd, @")
  else
    call system(a:cmd, @")
  endif
endfunction

function! s:clipboard_paste(cmd)
  if empty(a:cmd)
    if has('clipboard') && !s:is_unix
      let @" = @+
      return
    endif
    if executable('pbpaste')
      let l:cmd = 'pbpaste'
    else
      call s:echoerr('clipboard not found!') | return
    endif
    let @" = system(l:cmd)
  else
    let @" = system(a:cmd)
  endif
endfunction

" Cd <path> / :Cdalternate / :Cdhome / :Cdbuffer / :Cdproject [:]cmd... {{{2
command! -nargs=1 -complete=dir Cd call <SID>cd('', <q-args>)
command! -nargs=* -complete=command Cdalternate call <SID>cd('alternate', <q-args>)
command! -nargs=* -complete=command Cdhome call <SID>cd('home', <q-args>)
command! -nargs=* -complete=command Cdbuffer call <SID>cd('buffer', <q-args>)
command! -nargs=* -complete=command Cdproject call <SID>cd('project', <q-args>)

function! s:cd(flag, args)
  let cmd = a:args
  if a:flag ==# 'alternate'
    let path = fnamemodify(bufname('#'), '%:p:h')
  elseif a:flag ==# 'home'
    let path = expand('~')
  elseif a:flag ==# 'project'
    let path = s:get_project_dir()
  elseif a:flag ==# 'buffer'
    let path = s:get_buf_dir()
  else
    if a:args =~ '^:'
      call s:echoerr('path argument is required!') | return
    endif
    " Cd: split argument as path & cmd
    let path = substitute(a:args, '\v^(.{}) :.+$', '\1', '')
    let cmd = a:args[len(path)+1:]
  endif

  if !isdirectory(path)
    let path = expand(path)
  endif
  if !isdirectory(path)
    let path = fnamemodify(path, ':h')
  endif
  if !isdirectory(path)
    call s:echoerr('not a directory: ' . a:args) | return
  endif

  if !empty(cmd)
    let old_cwd = getcwd()
    let buf = bufnr('')
    try
      " use buffer variable to store cwd if `exe` switch to new window
      let b:vimrc_old_cwd = old_cwd
      exe 'lcd' fnameescape(path)
      exe cmd
    finally
      if buf == bufnr('')
        if exists('b:vimrc_old_cwd')
          unlet b:vimrc_old_cwd
        endif
        exe 'lcd' fnameescape(old_cwd)
      endif
    endtry
  else
    exe 'lcd' fnameescape(path)
    if &buftype == 'terminal'
      call term_sendkeys(bufnr(''), 'cd ' . shellescape(path))
    endif
  endif
endfunction

function! s:cd_reset()
  if exists('b:vimrc_old_cwd')
    try
      exe 'lcd' fnameescape(b:vimrc_old_cwd)
    finally
      unlet b:vimrc_old_cwd
    endtry
  endif
endfunction

augroup vimrc_cd
  au!
  au BufEnter * call s:cd_reset()
augroup END

function! s:get_buf_dir()
  let path = expand('%:p:h')
  if empty(path) || &buftype == 'terminal'
    let path = getcwd()
  endif
  return path
endfunction

function! s:get_project_dir()
  let path = s:get_buf_dir()
  while 1
    if isdirectory(path . '/.git')
      return path
    endif
    if filereadable(path . '/.git')
      " git submodule
      return path
    endif
    let parent = fnamemodify(path, ':h')
    if path == parent
      return ''
    endif
    let path = parent
  endwhile
endfunction

" execute current line (or select lines), comment removed (see keymap) {{{2
function! s:execute_lines(mode)
  if a:mode == 'n'
    let lines = [getline('.')]
  elseif a:mode == 'v'
    let t = @"
    silent normal gvy
    let lines = split(@", "\n")
    let @" = t
  endif
  let result = []
  for l:i in lines
    " TODO add more comment (or based on filetype).
    let result = add(result, substitute(l:i, '\v^\s*(//|#|"|--)+', '', ''))
  endfor
  let result = join(result, "\n")
  echom result
  echo 'execute? y/N '
  if nr2char(getchar()) ==? 'y'
    redraws | execute 'Cdbuffer' result
  else
    redraws | echon 'cancelled.'
  endif
endfunction

" gx related (NOTE: key `gx` overwritten) {{{2
nnoremap <silent> gx :call <SID>gx('n')<CR>
vnoremap <silent> gx :<C-u>call <SID>gx('v')<CR>

" TODO fix quote / escape
function! s:gx_open_cmd(s)
  if executable('xdg-open')
    return ['xdg-open', a:s]
  elseif executable('open')
    return ['open', a:s]
  elseif s:is_win32
    " TODO fix open for win32
    return ['cmd', '/c', isdirectory(a:s) ? 'explorer' : 'start', a:s]
  else
    call s:echoerr('do not know how to open') | return
  endif
endfunction

" TODO show error?
function! s:gx_open(...)
  let text = join(getline(1, '$'), "\n")
  if empty(text)
    return
  endif
  if empty(a:0)
    let open_cmd = s:gx_open_cmd(text)
  else
    let open_cmd = [a:1, text]
  endif
  if empty(open_cmd)
    return
  endif
  call job_start(open_cmd, {'stoponexit': ''})
endfunction

function! s:gx_open_gx(...)
  if a:0 == 1
    call s:gx_open(a:1)
  else
    call s:gx_open()
  endif
  let winnr = winnr()
  wincmd p
  execute winnr . 'wincmd c'
endfunction

function! s:gx_vim(...)
  " a:1 -> cmd; a:2 -> text modifier; a: 3 -> post string.
  let text = join(getline(1, '$'), "\n")
  if empty(text)
    return
  endif
  if empty(a:0)
    let cmd = text
  else
    if a:0 >= 2 && !empty(a:2)
      let text = function(a:2)(text)
    endif
    let cmd = a:1 . ' ' . text
    if a:0 >= 3 && !empty(a:3)
      let cmd .= a:3
    endif
  endif
  exe cmd
endfunction

function! s:gx(mode) abort
  if a:mode == 'v'
    let t = @"
    silent normal gvy
    let text = @"
    let @" = t
  else
    let text = expand(get(g:, 'netrw_gx', '<cfile>'))
  endif
  exe printf('bel %dnew', &cwh)
  " a special filetype
  setl ft=gx
  for line in split(text, "\n")
    call append('$', line)
  endfor
  norm gg"_dd
endfunction

" export SID (:h SID); variable: g:vimrc_sid {{{2
function! s:get_sid(filename)
  for i in split(execute('scriptnames'), "\n")
    let id = substitute(i, '\v^\s*(\d+): .*$', '\1', '')
    let file = substitute(i, '\v^\s*\d+: ', '', '')
    if a:filename ==# expand(file)
      return id
    endif
  endfor
  return 0
endfunction
if exists('*execute')
  let g:vimrc_sid = s:get_sid(expand('<sfile>'))
endif

" switch number / relativenumber {{{2
function! s:switch_nu_rnu() abort
  " patch-7.3.1115: set one of nu / rnu will affect another.
  if v:version < 704
    " [1, 0] -> [0, 0] -> [0, 1] -> [1, 0]
    if &nu
      setl nonu
    elseif &rnu
      setl nu
    else
      setl rnu
    endif
    return
  endif
  " no [0, 1]
  let presents = [[1, 1], [1, 0], [0, 0], [1, 1]]
  let idx = index(presents, [&l:nu, &l:rnu])
  let [&l:nu, &l:rnu] = presents[idx+1]
endfunction

" keymap {{{2
" terminal <C-Space>
map <Nul> <C-Space>
map! <Nul> <C-Space>
if exists(':tmap') == 2
  tmap <Nul> <C-Space>
endif

" completion
inoremap <C-Space> <C-x><C-o>

" clear hlsearch
nnoremap <silent> <Leader>l :noh<CR>

" custom text object
vnoremap aa :<C-u>normal! ggVG<CR>
onoremap aa :<C-u>normal! ggVG<CR>
vnoremap al :<C-u>normal! 0v$h<CR>
onoremap al :<C-u>normal! 0v$h<CR>
vnoremap il :<C-u>normal! ^vg_<CR>
onoremap il :<C-u>normal! ^vg_<CR>

" clipboard
nnoremap <Leader>y :call <SID>clipboard_copy("")<CR>
nnoremap <Leader>p :call <SID>clipboard_paste("")<CR>

" filelist buffer; vim-filelist
nmap <Leader>f <Plug>(filelist_show)

" simple tasks: tasks.vim
nmap <Leader>r <Plug>(tasks-select)
vmap <Leader>r <Plug>(tasks-select)

" execute current line
nnoremap <Leader><CR> :call <SID>execute_lines('n')<CR>
vnoremap <Leader><CR> :<C-u>call <SID>execute_lines('v')<CR>

" terminal escape
if exists(':tnoremap')
  tnoremap <C-Space> <C-\><C-n>
  if !has('nvim')
    tnoremap <C-w> <C-w>.
  endif
endif

" switch nu / rnu
nnoremap <silent> <Leader>n :call <SID>switch_nu_rnu()<CR>

" filetype setting {{{2
augroup vimrc_filetype
  au!
  au BufNewFile,BufRead *.gv setl ft=dot
  au FileType vim setl sw=2
  au FileType yaml setl sw=2 indentkeys-=0#
  au FileType zig setl fp=zig\ fmt\ --stdin
  au FileType markdown setl tw=78

  " open plugin directory
  au FileType vim nnoremap <buffer> <LocalLeader>e <cmd>e ~/vimfiles/plugin<CR>

  " quickfix window
  au FileType qf let &l:stl = &g:stl

  " viml completion
  au FileType vim inoremap <buffer> <C-Space> <C-x><C-v>

  " markdown checkbox {{{
  function! s:markdown_checkbox()
    hi link CheckboxUnchecked Type
    hi link CheckboxChecked Comment
    syn match CheckboxUnchecked '\v^\s*- \[ \] '
    syn match CheckboxChecked '\v^\s*- \[X\] '
  endfunction

  function! s:markdown_toggle_task_status()
    let lineno = line('.')
    let line = getline(lineno)
    if line =~# '\v^\s*- \[X\] '
      let line = substitute(line, '\v(^\s*- )@<=\[X\] ', '', '')
    elseif line =~# '\v^\s*- \[ \] '
      let line = substitute(line, '\v(^\s*- \[)@<= ', 'X', '')
    elseif line =~# '\v^\s*- '
      let line = substitute(line, '\v(^\s*-)@<= ', ' [ ] ', '')
    endif
    call setline(lineno, line)
  endfunction
  " }}}
  au FileType markdown call s:markdown_checkbox() | nnoremap <buffer>
        \ <LocalLeader>c :call <SID>markdown_toggle_task_status()<CR>

  " simple filelist (vim-filelist)
  function! s:filelist_init()
    nmap <buffer> <LocalLeader><CR> <Plug>(filelist_cd)
    nmap <buffer> <CR> <Plug>(filelist_edit)
  endfunction
  au FileType filelist call <SID>filelist_init()

  " gx
  function! s:gx_init()
    setl buftype=nofile noswapfile
    setl bufhidden=hide
    if executable('qutebrowser')
      nnoremap <buffer> <LocalLeader>s :call <SID>gx_open('qutebrowser')<CR>
    endif
    nnoremap <buffer> gx :call <SID>gx_open_gx()<CR>
    if executable('qutebrowser') && s:has_gui
      nnoremap <buffer> gs :call <SID>gx_open_gx('qutebrowser')<CR>
    endif
    nnoremap <buffer> <LocalLeader>f :call <SID>gx_open()<CR>
    nnoremap <buffer> <LocalLeader>v :call <SID>gx_vim('wincmd p \|')<CR>
  endfunction
  au FileType gx call <SID>gx_init()
augroup END

" :h ft-sh-syntax
let g:is_posix = 1

" finally {{{2
" e.g. <Space><Space>
nnoremap <Leader><Leader> :nmap <Char-60>Leader<Char-62><CR>
" e.g. <Space>;; / \\
execute 'nnoremap <LocalLeader>' .
      \ (len(maplocalleader) > 1 ? matchstr(maplocalleader, '.$') : '<LocalLeader>') .
      \ ' :nmap <Char-60>LocalLeader<Char-62><CR>'

" }}}1

" UserCommand {{{1
" snippet; :Scratch [filetype] / :ScratchNew [filetype] (with new window) {{{2
command -nargs=? -complete=filetype Scratch call <SID>scratch(<q-args>)
command! -nargs=? -complete=filetype
      \ ScratchNew call <SID>snippet_in_new_window(<q-args>)

function! s:scratch(ft) abort
  enew | setl buftype=nofile noswapfile bufhidden=hide
  if !empty(a:ft)
    exe 'setl ft=' . a:ft
  endif
endfunction

function! s:snippet_in_new_window(ft) abort
  exe printf('bel %dnew', &cwh)
  setl buftype=nofile noswapfile
  setl bufhidden=hide
  if !empty(a:ft)
    exe 'setl ft=' . a:ft
  endif
endfunction

" run vim command; :KvimRun {vim_command}... {{{2
command! -nargs=+ -complete=command KvimRun call s:show_output(execute(<q-args>))

" vim expr; :KvimExpr {vim_expr}... {{{2
command! -nargs=+ -complete=expression KvimExpr call s:show_output(eval(<q-args>))

function! s:show_output(data) abort
  ScratchNew
  for line in split(a:data, "\n")
    call append('$', line)
  endfor
  norm gg"_dd
endfunction

" insert shebang based on filetype; :KshebangInsert [content after "#!/usr/bin/env "] {{{2
command! -nargs=* -complete=shellcmd KshebangInsert
      \ call <SID>shebang_insert(<q-args>)

let g:vimrc#shebang_lines = {
      \'awk': 'awk -f', 'javascript': 'node', 'lua': 'lua',
      \'perl': 'perl', 'python': 'python', 'ruby': 'ruby',
      \'scheme': 'chez --script', 'sh': 'sh', 'zsh': 'zsh'
      \}

function! s:shebang_insert(args) abort
  let first_line = getline(1)
  if len(first_line) >= 2 && first_line[0:1] ==# '#!'
    " shebang exists
    throw 'shebang exists!'
  endif
  let shebang = '#!/usr/bin/env'
  if !empty(a:args)
    let shebang = shebang . ' ' . a:args
  elseif has_key(g:vimrc#shebang_lines, &ft)
    let shebang = shebang . ' ' . g:vimrc#shebang_lines[&ft]
  else
    throw 'shebang: which interpreter to run?'
  endif
  " insert at first line and leave cursor here (for further modification)
  normal ggO<Esc>
  let ret = setline(1, shebang)
  if ret == 0 " success
    normal $
  else
    throw 'setting shebang error!'
  endif
endfunction

" match long line; :KmatchLongLine {number} {{{2
" Refer: https://stackoverflow.com/a/1117367
command! -nargs=1 KmatchLongLine exe '/\%>' . <args> . 'v.\+'

" `J` with custom seperator; <visual>:J sep... {{{2
command! -nargs=1 -range J call s:join_line(<q-args>)
function! s:join_line(sep)
  let buf = @"
  try
    norm gv
    norm x
    let @" = substitute(@", "\n", a:sep, 'g')
    norm P
  finally
    let @" = buf
  endtry
endfunction

" edit selected line / column; :Kjump {{{2
command! -nargs=+ Kjump call <SID>jump_line_col(<f-args>)
function! s:jump_line_col(line, ...) abort
  execute 'normal' a:line . 'gg'
  if a:0 > 0
    let col = a:1
    if col > 1
      execute 'normal 0' . (col-1) . 'l'
    endif
  endif
endfunction

" Selection() {{{2
function! Selection() abort
  let tmp = @"
  try
    silent normal gvy
    return @"
  finally
    let @" = tmp
  endtry
endfunction

" :SetCmdText / SetCmdText() {{{2
function! SetCmdText(text) abort
  call feedkeys(':' .. a:text, 't')
endfunction

command! -nargs=+ SetCmdText call SetCmdText(<q-args>)

" `*` / `#` in visual mode (like `g*` / `g#`); dep: Selection() {{{2
vnoremap * :<C-u>call feedkeys('/\V' .. substitute(escape(Selection(), '\/'), "\n", '\\n', 'g') .. "\n", 't')<CR>
vnoremap # :<C-u>call feedkeys('?\V' .. substitute(escape(Selection(), '\/'), "\n", '\\n', 'g') .. "\n", 't')<CR>

" :Jobrun / :Jobstop / :Joblist / :Jobclear {{{2
if exists('*job_start')
  command! -range=0 -nargs=+ Jobrun call
        \ s:job_run(<q-args>, #{range: <range>, line1: <line1>, line2: <line2>})
  command! -nargs=* -bang -complete=custom,s:job_stop_comp Jobstop call
        \ s:job_stop(<q-args>, <bang>0 ? 'kill' : 'term')
  command! Joblist call s:job_list()
  command! -count Jobclear call s:job_clear(<count>)
endif

let s:job_dict = {}

function! s:job_exit_cb(job, ret) dict abort
  let buf = self.bufnr
  call appendbufline(buf, '$', '')
  call appendbufline(buf, '$', '===========================')
  call appendbufline(buf, '$', 'command finished with code ' . a:ret)
endfunction

function! s:job_run(cmd, opt) abort " {{{3
  if exists(':Sh') != 2
    throw 'depends on vim-sh plugin!'
  endif
  if exists(':ScratchNew') != 2
    throw 'depends on `:ScratchNew`!'
  endif
  let [cmd, opt] = [a:cmd, a:opt]
  if match(cmd, '^-') >= 0
    let tmp = matchlist(cmd, '\v^(-\S+)\s+(.*)$')
    let cmd = tmp[2]
    let flag = tmp[1] . 'n'
  else
    let flag = '-n'
  endif
  let cmd_short = cmd
  if opt.range != 0
    let cmd = printf('%s,%sSh %s %s', opt.line1, opt.line2, flag, cmd)
  else
    let cmd = printf('Sh %s %s', flag, cmd)
  endif
  let job_d = json_decode(execute(cmd))
  ScratchNew
  let bufnr = bufnr()
  let d = #{bufnr: bufnr, func: function('s:job_exit_cb')}
  wincmd p
  call extend(s:job_dict, {
        \ bufnr: #{
        \  job: job_start(
        \    job_d.cmd, extend(job_d.opt, #{
        \      out_io: 'buffer', err_io: 'buffer',
        \      out_buf: bufnr, err_buf: bufnr,
        \      exit_cb: d.func,
        \    })
        \   ),
        \  cmd: cmd_short,
        \  }
        \ })
endfunction

function! s:job_stop(id, sig) abort " {{{3
  if empty(a:id)
    let id = bufnr()
  else
    let id = str2nr(matchstr(a:id, '\v^\d+'))
  endif
  if has_key(s:job_dict, id)
    call job_stop(s:job_dict[id].job, a:sig)
  else
    throw 'job not found: buffer id ' . id
  endif
endfunction
" }}}

function! s:job_stop_comp(A, L, P) abort
  let result = []
  for [k, v] in items(s:job_dict)
    if v.job->job_status() == 'run'
      call add(result, printf('%s: %s', k, v.cmd))
    endif
  endfor
  return join(result, "\n")
endfunction

function! s:job_list() abort
  for [k, v] in items(s:job_dict)
    echo printf("%s:\t%s\t%s", k, v.job, v.cmd)
  endfor
endfunction

function! s:job_clear(num) abort
  for item in a:num ? [a:num] : keys(s:job_dict)
    let job = get(s:job_dict, item)
    if !empty(job)
      if job.job->job_info().status != 'run'
        call remove(s:job_dict, item)
      endif
    endif
  endfor
endfunction

" :Pack / :PackClean; a simple plugin manager (for vim8). {{{2
"
" usage:
"   Pack [url][, {opt}]
"   PackClean
" example:
"   Pack 'tpope/vim-sensible'
"   Pack 'https://github.com/Shougo/ddc.vim', #{branch: 'v0.14.0'}
"   Pack 'https://github.com/dracula/vim', #{as: 'dracula'}
"   Pack  " output command for install / update
"   PackClean  " prompt to clean not `Pack`ed dir
" opt:
"   as; branch; commit.
" complete workflow:
"   after running `:Pack!`, run the new file with sh with
"   `:Jobrun sh %`, `:!sh %:S`, or other way to run external command.
"
" TODO:
"   helptag;
if exists(':packadd') == 2
  " clear list on (re)loading vimrc.
  let s:plugins = {}
  let s:plugins_root = fnamemodify(expand('<sfile>'), ':p:h') . '/pack/rc/opt'
  command! -nargs=* -bang -complete=custom,s:pack_comp Pack call s:pack(<bang>0, <args>)
  command! -bang PackClean call s:pack_clean(<bang>0)
endif

" s:pack() {{{
function! s:pack(bang, ...) abort
  if a:0 > 0
    " TODO check input.
    let l:plugin = a:1
    let l:url = s:pack_construct_url(l:plugin)
    let l:opt = a:0 > 1 ? a:2 : {}
    let l:dir = get(l:opt, 'as', s:pack_extract_git_dir(l:url))
    let l:opt.branch = get(l:opt, 'branch', '')
    let l:opt.commit = get(l:opt, 'commit', '')
    let l:opt.skip = get(l:opt, 'skip', 0)
    let l:opt.dir = l:dir
    let l:opt.url = l:url
    if !l:opt.skip
      if has('vim_starting')
        silent! execute 'packadd!' l:dir
      else
        if index(&rtp->split(',')->map({_, i -> i->split('\v[\/]')[-1]}), l:opt.dir) < 0
          " only load if not in rtp.
          execute 'packadd' l:dir
        endif
      endif
    endif
    let s:plugins[l:plugin] = l:opt
  else
    let l:lines = []
    if a:bang
      let l:tempfile = tempname()
    endif
    if !isdirectory(s:plugins_root)
      call mkdir(s:plugins_root, 'p')
    endif

    " check is plugin is already available.
    for [l:k, l:v] in items(s:plugins)
      let l:i = globpath(&pp, printf('pack/*/opt/%s', l:v.dir), 0, 1)
      if empty(l:i)
        if has_key(l:v, 'path')
          call remove(l:v, 'path')
        endif
      else
        let l:v['path'] = l:i[0]
      endif
    endfor

    " generate command.
    for [l:k, l:v] in items(s:plugins)
      " TODO check quote in various fields.
      call add(l:lines, printf('# %s', l:k))
      if has_key(l:v, 'path')
        if isdirectory(l:v.path . '/.git') || filereadable(l:v.path . '/.git')
          " TODO fetch depth.
          call add(l:lines, printf('git -C %s pull', shellescape(l:v.path)))
        else
          call add(l:lines, '# is not git repository, skip.')
        endif
      else
        if !empty(l:v.commit)
          call add(l:lines,
                \ printf('git -C %s clone -n %s %s && git -C %s/%s checkout %s',
                \ shellescape(s:plugins_root), l:v.url, l:v.dir,
                \ shellescape(s:plugins_root), l:v.dir, l:v.commit,
                \ ))
        elseif !empty(l:v.branch)
          call add(l:lines,
                \ printf('git -C %s clone --depth 1 -b %s %s %s',
                \ shellescape(s:plugins_root), l:v.branch, l:v.url, l:v.dir))
        else
          call add(l:lines, printf('git -C %s clone --depth 1 %s %s',
                \ shellescape(s:plugins_root), l:v.url, l:v.dir))
        endif
      endif
      call add(l:lines, '')
    endfor

    " output report.
    if a:bang
      let l:lines =
            \ ['#!/bin/sh',
            \ "{ grep -Ev '^(#|$)'" .
            \ ' | tr "\n" "\0" | xargs -r -0 -n 1 -P 5 sh -c; } <<\EOF']
            \ + [''] + l:lines + ['EOF']
      call writefile(l:lines, l:tempfile)
      wincmd v
      execute 'e' fnameescape(l:tempfile)
      setl ft=sh
    else
      for l:i in l:lines
        if match(l:i, '^#') >= 0
          echohl Comment | echo l:i | echohl None
        else
          echo l:i
        endif
      endfor
      if !empty(l:lines)
        echohl Special | echo 'run with bang (:Pack!) to generate a shellscript.' | echohl None
      endif
    endif
  endif
endfunction
" }}}

" s:pack_clean() {{{
function! s:pack_clean(bang) abort
  let l:keep = []
  " it actually matches both files and dirs.
  let l:dir_clean = []
  for l:i in values(s:plugins)
    call add(l:keep, l:i.dir)
  endfor
  for l:i in globpath(s:plugins_root, '*', 0, 1)
    if index(l:keep, split(l:i, '\v[\/]')[-1]) < 0
          \ || !isdirectory(l:i)
          \ || (isdirectory(l:i) && index([ ['.git'], [] ], readdir(l:i)) >= 0)
      " remove dir not defined as plugin or empty (/ broken .git) dir;
      call add(l:dir_clean, l:i)
    endif
  endfor
  if empty(l:dir_clean)
    echo 'no dir / file to clean.'
    return
  endif

  if a:bang
    let l:tempfile = tempname()
    let l:lines = ['#!/bin/sh', 'set -e', '', '{', '']
    for l:i in l:dir_clean
      call add(l:lines, printf('rm -rf -- %s', shellescape(l:i)))
    endfor
    let l:lines = l:lines + ['', '} && echo "delete success." || echo "delete failed."']
    call writefile(l:lines, l:tempfile)
    wincmd v
    execute 'e' fnameescape(l:tempfile)
    setl ft=sh
    return
  endif

  echo 'dir / file to clean:'
  for l:i in l:dir_clean
    echohl WarningMsg | echo l:i | echohl None
  endfor
  echohl Special | echo 'run with bang (:PackClean!) to generate a shellscript.' | echohl None
  echo 'clean them? [y/N] '
  let l:yes = nr2char(getchar()) ==? 'y'
  let l:failed = 0
  if l:yes
    for l:i in l:dir_clean
      let l:failed += (delete(l:i, 'rf') != 0)
    endfor
    echo printf('dirs / files removed. %s', l:failed > 0 ? l:failed . ' failed.' : '')
  else
    redraws | echon 'cancelled.'
  endif
endfunction
" }}}

" helper functions. {{{3
function! s:pack_construct_url(name) abort
  let name = a:name
  if name =~ '\v^(https|http|git|ssh)\://.+'
    return name
  else
    " TODO handle dirname as param, like vim-sh.
    return printf('https://github.com/%s', name)
  endif
endfunction

function! s:pack_extract_git_dir(url) abort
  let result = matchstr(a:url, '\v[^/]+$')
  let result = substitute(result, '\v\.git$', '', '')
  return result
endfunction

function! s:pack_comp(A, L, P) abort
  let l:loaded = split(&rtp, ',')->map({_, i -> i->split('\v[\/]')[-1]})
  let l:result = []
  for [l:k, l:v] in items(s:plugins)
    if index(l:loaded, l:v.dir) < 0
      call add(l:result, string(l:k))
    endif
  endfor
  return l:result->join("\n")
endfunction

" :Mpc {{{2
if executable('mpc')
  command! Mpc call s:mpc_main()

  let s:mpc_prop_type = 'song'

  function! s:mpc_main() abort
    enew | setl filetype=mpc buftype=nofile noswapfile nobuflisted
    let l:buf = bufnr()
    call prop_type_add(s:mpc_prop_type, {'bufnr': l:buf})
    let l:i = 1
    for line in split(system('mpc playlist'), "\n")
      call setline(l:i, line)
      call prop_add(l:i, 1, {'type': s:mpc_prop_type, 'id': l:i, 'bufnr': l:buf})
      let l:i += 1
    endfor
    nnoremap <buffer> <CR> <cmd>call <SID>mpc_play()<CR>
  endfunction

  function! s:mpc_play() abort
    let prop = prop_list(line('.'))
    if len(prop) == 0
      return
    endif

    let prop = prop[-1]
    if prop['type'] ==# s:mpc_prop_type
      let l:id = prop['id']
      silent call job_start(printf('mpc play %d', l:id))
    endif
  endfunction
endif

" :KqutebrowserEditCmd {{{2
if !empty($QUTE_FIFO)
  command! KqutebrowserEditCmd call s:qutebrowser_edit_cmd()

  function! s:qutebrowser_edit_cmd()
    setl buftype=nofile noswapfile
    call setline(1, $QUTE_COMMANDLINE_TEXT[1:])
    call setline(2, '')
    call setline(3, 'hit `<Space>q` to save cmd (first line) and quit')
    nnoremap <buffer> <Space>q :call writefile(['set-cmd-text -s :' . getline(1)], $QUTE_FIFO) \| q<CR>
  endfunction
endif

" :Tmux {{{2
if exists("$TMUX")
  command! -nargs=1 -bar Tmux call s:tmux_open_window(<q-args>)

  function! s:tmux_open_window(args)
    let options = {'c': 'neww', 's': 'splitw -v', 'v': 'splitw -h'}
    let ch = match(a:args, '\s')
    if ch == -1
      let [option, args] = [a:args, '']
    else
      let [option, args] = [a:args[:ch], a:args[ch:]]
    endif
    let option = get(options, trim(option))
    if empty(option)
      throw 'unknown option: ' . a:args . '; valid: ' . join(keys(options), ' / ')
    endif
    call system("tmux " . option . " -c " . shellescape(getcwd()) . args)
  endfunction
endif

" terminal-api related user function {{{2
if exists(':terminal') == 2
" sync terminal path to buffer path.
" TODO follow cd even when terminal buffer not in focus (with event?).
  function! Tapi_cd(nr, arg)
    if bufnr() == a:nr
      execute 'lcd' fnameescape(a:arg[0])
    endif
  endfunction
endif
" }}}1

" load plugin {{{1
if exists(':Pack') == 2
  Pack 'vim-filelist'
  Pack 'vim-jump'
  Pack 'vim-sh'
endif
" }}}1

" source local vimrc {{{1
if filereadable(s:nix_dir . '/vimfiles/' . 'vimrc.local')
  " if necessary, load plugin in vimrc.local
  exe 'source' fnameescape(s:nix_dir . '/vimfiles/' . 'vimrc.local')
else
  " use default plugin
  exe 'source' fnameescape(s:nix_dir . '/vimfiles/' . 'vimrc.pkgs')
endif
" }}}1

if !has('win32') | finish | endif
" set $HOME (for unix shell), $PATH, $VIM ... {{{1
function! s:tr_slash(s)
  return substitute(a:s, '\', '/', 'g')
endfunction
let s:nix_dir = s:tr_slash(s:nix_dir)

" make it work in cygwin vim.
let $VIM = s:tr_slash($VIM)
let $VIMRUNTIME = s:tr_slash($VIMRUNTIME)
let $MYVIMRC = s:tr_slash($MYVIMRC)

if !exists('$HOME')
  let $HOME = s:tr_slash($USERPROFILE)
else
  let $HOME = s:tr_slash($HOME)
endif

let s:path = map(split($PATH, ';'), 's:tr_slash(v:val)')
for s:i in [
      \ s:nix_dir . '/vimfiles/bin',
      \ s:nix_dir . '/MinGit/usr/bin',
      \ s:nix_dir . '/MinGit/cmd',
      \ s:nix_dir . '/bin',
      \ ]
  if index(s:path, s:i) < 0 && isdirectory(s:i)
    let $PATH = s:i . ';' . $PATH
  endif
endfor
" cygwin vim -> vim -> others.
let $PATH = '/usr/bin;/bin;' . $VIMRUNTIME . ';' . $PATH
unlet s:path
unlet s:i

" vim-sh config {{{1
for s:i in [
      \ s:tr_slash(expand('~\nix\msys2\usr\bin\zsh')),
      \ 'C:/msys64/usr/bin/zsh',
      \ 'C:/msys64/usr/bin/bash',
      \ 'C:/msys32/usr/bin/zsh',
      \ 'C:/msys32/usr/bin/bash',
      \ 'C:/Program Files/Git/usr/bin/bash',
      \ 'C:/Program Files (x86)/Git/usr/bin/bash',
      \ ]
  if executable(s:i)
    let g:sh_path = s:i
    break
  endif
endfor
unlet s:i

" busybox sh rc
let $ENV = expand(s:nix_dir . '/.config/env.sh')
let $SH_RC_LOCAL = expand(s:nix_dir . '/local.sh')
" }}}
